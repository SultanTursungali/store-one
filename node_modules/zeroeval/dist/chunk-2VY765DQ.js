// src/observability/Span.ts
import { randomUUID } from "crypto";
var Span = class {
  constructor(name, traceId) {
    this.spanId = randomUUID();
    this.startTime = Date.now();
    this.attributes = {};
    this.tags = {};
    this.traceTags = {};
    this.sessionTags = {};
    this.signals = {};
    this.status = "ok";
    this.name = name;
    this.traceId = traceId ?? randomUUID();
  }
  end() {
    this.endTime = Date.now();
  }
  get durationMs() {
    return this.endTime ? this.endTime - this.startTime : void 0;
  }
  setError(info) {
    this.error = info;
    this.status = "error";
  }
  setIO(input, output) {
    if (input !== void 0) {
      this.inputData = typeof input === "string" ? input : JSON.stringify(input);
    }
    if (output !== void 0) {
      this.outputData = typeof output === "string" ? output : JSON.stringify(output);
    }
  }
  addSignal(name, value, type) {
    let signalType = type;
    if (!signalType) {
      if (typeof value === "boolean") {
        signalType = "boolean";
      } else if (typeof value === "number") {
        signalType = "numerical";
      } else {
        const strVal = String(value).toLowerCase();
        if (strVal === "true" || strVal === "false") {
          signalType = "boolean";
        } else if (!isNaN(Number(value))) {
          signalType = "numerical";
        } else {
          signalType = "boolean";
        }
      }
    }
    this.signals[name] = {
      value,
      type: signalType
    };
  }
  toJSON() {
    return {
      span_id: this.spanId,
      trace_id: this.traceId,
      parent_id: this.parentId,
      name: this.name,
      start_time: new Date(this.startTime).toISOString(),
      end_time: this.endTime ? new Date(this.endTime).toISOString() : void 0,
      duration_ms: this.durationMs,
      session_id: this.sessionId,
      session_name: this.sessionName,
      attributes: this.attributes,
      tags: this.tags,
      trace_tags: this.traceTags,
      session_tags: this.sessionTags,
      signals: this.signals,
      input_data: this.inputData,
      output_data: this.outputData,
      error_code: this.error?.code,
      error_message: this.error?.message,
      error_stack: this.error?.stack,
      status: this.status
    };
  }
};

// src/observability/Tracer.ts
import { AsyncLocalStorage } from "async_hooks";
import { randomUUID as randomUUID2 } from "crypto";

// src/observability/logger.ts
var colors = {
  grey: "\x1B[38;5;244m",
  blue: "\x1B[34;1m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  red: "\x1B[31m",
  boldRed: "\x1B[31;1m",
  reset: "\x1B[0m"
};
var _Logger = class _Logger {
  constructor(name) {
    this.name = name;
  }
  static setDebugMode(enabled) {
    _Logger.isDebugMode = enabled;
    _Logger.globalLevel = enabled ? 0 /* DEBUG */ : 2 /* WARN */;
    _Logger.bufferEarlyLogs = false;
    if (enabled && _Logger.earlyLogs.length > 0) {
      console.log("[zeroeval] Replaying buffered debug logs...");
      for (const log of _Logger.earlyLogs) {
        if (_Logger.globalLevel <= log.level) {
          const fn = log.level <= 1 /* INFO */ ? console.log : console.error;
          fn(
            log.logger.formatMessage(
              log.levelName,
              log.levelColor,
              log.message
            ),
            ...log.args
          );
        }
      }
      _Logger.earlyLogs = [];
    }
  }
  static isDebugEnabled() {
    return _Logger.isDebugMode;
  }
  formatTimestamp() {
    const now = /* @__PURE__ */ new Date();
    const hours = now.getHours().toString().padStart(2, "0");
    const minutes = now.getMinutes().toString().padStart(2, "0");
    const seconds = now.getSeconds().toString().padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  }
  formatMessage(level, levelColor, message) {
    if (!_Logger.isDebugMode) {
      return `[${this.name}] [${level}] ${message}`;
    }
    const timestamp = this.formatTimestamp();
    return `${colors.grey}[${timestamp}]${colors.reset} ${colors.blue}[${this.name}]${colors.reset} ${levelColor}[${level}]${colors.reset} ${message}`;
  }
  debug(message, ...args) {
    if (_Logger.bufferEarlyLogs && 0 /* DEBUG */ >= _Logger.globalLevel) {
      _Logger.earlyLogs.push({
        logger: this,
        level: 0 /* DEBUG */,
        levelName: "DEBUG",
        levelColor: colors.blue,
        message,
        args
      });
      return;
    }
    if (_Logger.globalLevel <= 0 /* DEBUG */) {
      console.log(this.formatMessage("DEBUG", colors.blue, message), ...args);
    }
  }
  info(message, ...args) {
    if (_Logger.bufferEarlyLogs && 1 /* INFO */ >= _Logger.globalLevel) {
      _Logger.earlyLogs.push({
        logger: this,
        level: 1 /* INFO */,
        levelName: "INFO",
        levelColor: colors.green,
        message,
        args
      });
      return;
    }
    if (_Logger.globalLevel <= 1 /* INFO */) {
      console.log(this.formatMessage("INFO", colors.green, message), ...args);
    }
  }
  warn(message, ...args) {
    if (_Logger.globalLevel <= 2 /* WARN */) {
      console.warn(this.formatMessage("WARN", colors.yellow, message), ...args);
    }
  }
  error(message, ...args) {
    if (_Logger.globalLevel <= 3 /* ERROR */) {
      console.error(this.formatMessage("ERROR", colors.red, message), ...args);
    }
  }
  critical(message, ...args) {
    if (_Logger.globalLevel <= 4 /* CRITICAL */) {
      console.error(
        this.formatMessage("CRITICAL", colors.boldRed, message),
        ...args
      );
    }
  }
  /**
   * Mask sensitive data like API keys for logging
   */
  static maskApiKey(apiKey) {
    if (!apiKey)
      return "Not set";
    if (apiKey.length <= 8)
      return "***";
    return `${apiKey.substring(0, 8)}...`;
  }
};
_Logger.globalLevel = 2 /* WARN */;
_Logger.isDebugMode = false;
_Logger.earlyLogs = [];
_Logger.bufferEarlyLogs = true;
var Logger = _Logger;
function getLogger(name) {
  return new Logger(name);
}

// src/observability/signalWriter.ts
var logger = getLogger("zeroeval.signalWriter");
var SignalWriter = class {
  getApiUrl() {
    return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
      /\/$/,
      ""
    );
  }
  getApiKey() {
    return process.env.ZEROEVAL_API_KEY;
  }
  /**
   * Send a single signal to the backend
   */
  async createSignal(signal) {
    const endpoint = `${this.getApiUrl()}/signals/`;
    const headers = {
      "Content-Type": "application/json"
    };
    const apiKey = this.getApiKey();
    if (apiKey)
      headers.Authorization = `Bearer ${apiKey}`;
    logger.debug(`[ZeroEval] Sending signal to ${endpoint}`);
    if (Logger.isDebugEnabled()) {
      logger.debug("[ZeroEval] Request headers:", {
        ...headers,
        Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
      });
      logger.debug("[ZeroEval] Request body:", JSON.stringify(signal, null, 2));
    }
    try {
      const startTime = Date.now();
      const res = await fetch(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(signal)
      });
      const duration = Date.now() - startTime;
      logger.debug(
        `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
      );
      const text = await res.text();
      if (Logger.isDebugEnabled()) {
        const responseHeaders = {};
        res.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });
        logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
        logger.debug(`[ZeroEval] Response body:`, text);
      }
      if (!res.ok) {
        logger.error(
          `[ZeroEval] Failed creating signal: ${res.status} ${text}`
        );
        return {
          status: "error",
          message: `Failed to create signal: ${res.status} ${text}`
        };
      }
      logger.info(
        `[ZeroEval] Successfully created signal for ${signal.entity_type}:${signal.entity_id} - ${signal.name}`
      );
      return JSON.parse(text);
    } catch (err) {
      logger.error("[ZeroEval] Error creating signal", err);
      if (Logger.isDebugEnabled()) {
        logger.debug("[ZeroEval] Error details:", {
          endpoint,
          signal,
          error: err instanceof Error ? {
            name: err.name,
            message: err.message,
            stack: err.stack
          } : err
        });
      }
      return {
        status: "error",
        message: `Error creating signal: ${err instanceof Error ? err.message : String(err)}`
      };
    }
  }
  /**
   * Send multiple signals to the backend in bulk
   */
  async createBulkSignals(signals) {
    const endpoint = `${this.getApiUrl()}/signals/bulk`;
    const headers = {
      "Content-Type": "application/json"
    };
    const apiKey = this.getApiKey();
    if (apiKey)
      headers.Authorization = `Bearer ${apiKey}`;
    const bulkRequest = { signals };
    logger.debug(
      `[ZeroEval] Sending ${signals.length} bulk signals to ${endpoint}`
    );
    if (Logger.isDebugEnabled()) {
      logger.debug("[ZeroEval] Request headers:", {
        ...headers,
        Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
      });
      logger.debug(
        "[ZeroEval] Request body:",
        JSON.stringify(bulkRequest, null, 2)
      );
    }
    try {
      const startTime = Date.now();
      const res = await fetch(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(bulkRequest)
      });
      const duration = Date.now() - startTime;
      logger.debug(
        `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
      );
      const text = await res.text();
      if (Logger.isDebugEnabled()) {
        const responseHeaders = {};
        res.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });
        logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
        logger.debug(`[ZeroEval] Response body:`, text);
      }
      if (!res.ok) {
        logger.error(
          `[ZeroEval] Failed creating bulk signals: ${res.status} ${text}`
        );
        return {
          status: "error",
          message: `Failed to create bulk signals: ${res.status} ${text}`
        };
      }
      logger.info(
        `[ZeroEval] Successfully created ${signals.length} bulk signals`
      );
      return JSON.parse(text);
    } catch (err) {
      logger.error("[ZeroEval] Error creating bulk signals", err);
      if (Logger.isDebugEnabled()) {
        logger.debug("[ZeroEval] Error details:", {
          endpoint,
          signalCount: signals.length,
          error: err instanceof Error ? {
            name: err.name,
            message: err.message,
            stack: err.stack
          } : err
        });
      }
      return {
        status: "error",
        message: `Error creating bulk signals: ${err instanceof Error ? err.message : String(err)}`
      };
    }
  }
  /**
   * Get all signals for a specific entity
   */
  async getEntitySignals(entityType, entityId) {
    const endpoint = `${this.getApiUrl()}/signals/entity/${entityType}/${entityId}`;
    const headers = {
      "Content-Type": "application/json"
    };
    const apiKey = this.getApiKey();
    if (apiKey)
      headers.Authorization = `Bearer ${apiKey}`;
    logger.debug(
      `[ZeroEval] Getting signals for ${entityType}:${entityId} from ${endpoint}`
    );
    if (Logger.isDebugEnabled()) {
      logger.debug("[ZeroEval] Request headers:", {
        ...headers,
        Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
      });
    }
    try {
      const startTime = Date.now();
      const res = await fetch(endpoint, {
        method: "GET",
        headers
      });
      const duration = Date.now() - startTime;
      logger.debug(
        `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
      );
      const text = await res.text();
      if (Logger.isDebugEnabled()) {
        const responseHeaders = {};
        res.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });
        logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
        logger.debug(`[ZeroEval] Response body:`, text);
      }
      if (!res.ok) {
        logger.error(
          `[ZeroEval] Failed getting entity signals: ${res.status} ${text}`
        );
        return null;
      }
      logger.info(
        `[ZeroEval] Successfully retrieved signals for ${entityType}:${entityId}`
      );
      return JSON.parse(text);
    } catch (err) {
      logger.error("[ZeroEval] Error getting entity signals", err);
      if (Logger.isDebugEnabled()) {
        logger.debug("[ZeroEval] Error details:", {
          endpoint,
          entityType,
          entityId,
          error: err instanceof Error ? {
            name: err.name,
            message: err.message,
            stack: err.stack
          } : err
        });
      }
      return null;
    }
  }
};
var signalWriter = new SignalWriter();

// src/observability/writer.ts
var logger2 = getLogger("zeroeval.writer");
var BackendSpanWriter = class {
  getApiUrl() {
    return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
      /\/$/,
      ""
    );
  }
  getApiKey() {
    return process.env.ZEROEVAL_API_KEY;
  }
  async write(spans) {
    if (!spans.length)
      return;
    const endpoint = `${this.getApiUrl()}/spans`;
    const headers = {
      "Content-Type": "application/json"
    };
    const apiKey = this.getApiKey();
    if (apiKey)
      headers.Authorization = `Bearer ${apiKey}`;
    const spansWithSignals = [];
    const traceIds = /* @__PURE__ */ new Set();
    const sessionIds = /* @__PURE__ */ new Set();
    const payload = spans.map((s) => {
      const base = typeof s.toJSON === "function" ? s.toJSON() : s;
      if (base.signals && Object.keys(base.signals).length > 0) {
        spansWithSignals.push({ spanId: base.span_id, signals: base.signals });
      }
      traceIds.add(base.trace_id);
      if (base.session_id)
        sessionIds.add(base.session_id);
      return {
        id: base.span_id,
        session_id: base.session_id,
        session_name: base.session_name,
        trace_id: base.trace_id,
        parent_span_id: base.parent_id,
        name: base.name,
        started_at: base.start_time,
        ended_at: base.end_time,
        duration_ms: base.duration_ms,
        attributes: base.attributes,
        status: base.status,
        input_data: base.input_data,
        output_data: base.output_data,
        code: base.code ?? base.attributes?.code,
        code_filepath: base.code_filepath ?? base.attributes?.code_filepath,
        code_lineno: base.code_lineno ?? base.attributes?.code_lineno,
        error_code: base.error_code,
        error_message: base.error_message,
        error_stack: String(base.error_stack ?? ""),
        tags: base.tags,
        trace_tags: base.trace_tags,
        session_tags: base.session_tags
      };
    });
    logger2.debug(`[ZeroEval] Sending ${payload.length} spans to ${endpoint}`);
    if (Logger.isDebugEnabled()) {
      logger2.debug("[ZeroEval] Request headers:", {
        ...headers,
        Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
      });
      logger2.debug(
        "[ZeroEval] Request body:",
        JSON.stringify(payload, null, 2)
      );
    }
    try {
      const startTime = Date.now();
      const res = await fetch(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      });
      const duration = Date.now() - startTime;
      logger2.debug(
        `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
      );
      const text = await res.text();
      if (Logger.isDebugEnabled()) {
        const responseHeaders = {};
        res.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });
        logger2.debug(`[ZeroEval] Response headers:`, responseHeaders);
        logger2.debug(`[ZeroEval] Response body:`, text);
      }
      if (!res.ok) {
        logger2.error(`[ZeroEval] Failed posting spans: ${res.status} ${text}`);
      } else {
        logger2.info(
          `[ZeroEval] Successfully posted ${payload.length} spans to ${endpoint}`
        );
        await this.sendSpanSignals(spansWithSignals);
        await this.flushTraceSessionSignals(
          Array.from(traceIds),
          Array.from(sessionIds)
        );
      }
    } catch (err) {
      logger2.error("[ZeroEval] Error posting spans", err);
      if (Logger.isDebugEnabled()) {
        logger2.debug("[ZeroEval] Error details:", {
          endpoint,
          spanCount: payload.length,
          error: err instanceof Error ? {
            name: err.name,
            message: err.message,
            stack: err.stack
          } : err
        });
      }
    }
  }
  async sendSpanSignals(spansWithSignals) {
    if (spansWithSignals.length === 0)
      return;
    const bulkSignals = [];
    for (const { spanId, signals } of spansWithSignals) {
      for (const [name, signal] of Object.entries(signals)) {
        bulkSignals.push({
          entity_type: "span",
          entity_id: spanId,
          name,
          value: signal.value,
          signal_type: signal.type
        });
      }
    }
    if (bulkSignals.length > 0) {
      try {
        await signalWriter.createBulkSignals(bulkSignals);
      } catch (err) {
        logger2.error("[ZeroEval] Error sending span signals", err);
      }
    }
  }
  async flushTraceSessionSignals(traceIds, sessionIds) {
    if (traceIds.length === 0 && sessionIds.length === 0)
      return;
    const { popPendingTraceSignals, popPendingSessionSignals } = await import("./pendingSignals-UV7XR3R3.js");
    const bulk = [];
    for (const tid of traceIds) {
      const signals = popPendingTraceSignals(tid);
      if (!signals)
        continue;
      for (const [name, sig] of Object.entries(signals)) {
        bulk.push({
          entity_type: "trace",
          entity_id: tid,
          name,
          value: sig.value,
          signal_type: sig.type
        });
      }
    }
    for (const sid of sessionIds) {
      const signals = popPendingSessionSignals(sid);
      if (!signals)
        continue;
      for (const [name, sig] of Object.entries(signals)) {
        bulk.push({
          entity_type: "session",
          entity_id: sid,
          name,
          value: sig.value,
          signal_type: sig.type
        });
      }
    }
    if (bulk.length > 0) {
      try {
        await signalWriter.createBulkSignals(bulk);
      } catch (err) {
        logger2.error("[ZeroEval] Error posting trace/session signals", err);
      }
    }
  }
};

// src/observability/Tracer.ts
import { setInterval } from "timers";

// src/observability/integrations/utils.ts
async function discoverIntegrations() {
  const integrations = {};
  try {
    await import("langchain");
    const { LangChainIntegration } = await import("./langchain-ESLSL4I4.js");
    integrations.langchain = LangChainIntegration;
  } catch (_) {
  }
  try {
    await import("langgraph");
    const { LangGraphIntegration } = await import("./langgraph-PBBJXGQD.js");
    integrations.langgraph = LangGraphIntegration;
  } catch (_) {
  }
  return integrations;
}

// src/observability/Tracer.ts
if (process.env.ZEROEVAL_DEBUG?.toLowerCase() === "true") {
  Logger.setDebugMode(true);
}
var logger3 = getLogger("zeroeval.tracer");
var als = new AsyncLocalStorage();
var Tracer = class {
  constructor() {
    this._writer = new BackendSpanWriter();
    this._buffer = [];
    this._flushIntervalMs = 1e4;
    // default 10 s
    this._maxSpans = 100;
    this._lastFlush = Date.now();
    this._activeTraceCounts = {};
    this._traceBuckets = {};
    this._integrations = {};
    this._shuttingDown = false;
    logger3.debug("Initializing tracer...");
    logger3.debug(
      `Tracer config: flush_interval=${this._flushIntervalMs}ms, max_spans=${this._maxSpans}`
    );
    setInterval(() => {
      if (Date.now() - this._lastFlush >= this._flushIntervalMs) {
        void this.flush().catch((error) => {
          logger3.error("[ZeroEval] Periodic flush failed:", error);
        });
      }
    }, 1e3).unref();
    void this._setupAvailableIntegrations();
    process.on("beforeExit", () => this.shutdown());
    process.on("SIGINT", () => {
      this.shutdown();
      process.exit();
    });
    process.on("SIGTERM", () => {
      this.shutdown();
      process.exit();
    });
  }
  /* CONFIG ----------------------------------------------------------------*/
  configure(opts = {}) {
    if (opts.flushInterval !== void 0) {
      this._flushIntervalMs = opts.flushInterval * 1e3;
      logger3.info(
        `Tracer flush_interval configured to ${opts.flushInterval}s.`
      );
    }
    if (opts.maxSpans !== void 0) {
      this._maxSpans = opts.maxSpans;
      logger3.info(`Tracer max_spans configured to ${opts.maxSpans}.`);
    }
    logger3.debug(`Tracer configuration updated:`, opts);
  }
  /* ACTIVE SPAN -----------------------------------------------------------*/
  currentSpan() {
    const stack = als.getStore();
    return stack && stack[stack.length - 1];
  }
  /* TRACING ---------------------------------------------------------------*/
  startSpan(name, opts = {}) {
    logger3.debug(`Starting span: ${name}`);
    const parent = this.currentSpan();
    const span = new Span(name, parent?.traceId);
    if (parent) {
      span.parentId = parent.spanId;
      span.sessionId = parent.sessionId;
      span.sessionName = parent.sessionName;
      span.tags = { ...parent.tags, ...opts.tags };
      logger3.debug(`Span ${name} inherits from parent ${parent.name}`);
    } else {
      span.sessionId = opts.sessionId ?? randomUUID2();
      span.sessionName = opts.sessionName;
      span.tags = { ...opts.tags };
      logger3.debug(
        `Span ${name} is a root span with session ${span.sessionId}`
      );
    }
    Object.assign(span.attributes, opts.attributes);
    const parentStack = als.getStore() ?? [];
    als.enterWith([...parentStack, span]);
    this._activeTraceCounts[span.traceId] = (this._activeTraceCounts[span.traceId] || 0) + 1;
    return span;
  }
  endSpan(span) {
    var _a, _b;
    if (!span.endTime)
      span.end();
    logger3.debug(`Ending span: ${span.name} (duration: ${span.durationMs}ms)`);
    const stack = als.getStore();
    if (stack && stack[stack.length - 1] === span) {
      stack.pop();
    }
    const traceBucket = (_a = this._traceBuckets)[_b = span.traceId] || (_a[_b] = []);
    traceBucket.push(span);
    this._activeTraceCounts[span.traceId] -= 1;
    if (this._activeTraceCounts[span.traceId] === 0) {
      delete this._activeTraceCounts[span.traceId];
      const ordered = traceBucket.sort((a) => a.parentId ? 1 : -1);
      delete this._traceBuckets[span.traceId];
      this._buffer.push(...ordered);
      logger3.debug(
        `Trace ${span.traceId} complete with ${ordered.length} spans`
      );
    }
    if (this._buffer.length >= this._maxSpans) {
      logger3.debug(
        `Buffer full (${this._buffer.length} spans), triggering flush`
      );
      void this.flush().catch((error) => {
        logger3.error("[ZeroEval] Buffer full flush failed:", error);
      });
    }
  }
  /* TAG HELPERS -----------------------------------------------------------*/
  addTraceTags(traceId, tags) {
    logger3.debug(`Adding trace tags to ${traceId}:`, tags);
    for (const span of this._traceBuckets[traceId] ?? [])
      Object.assign(span.tags, tags);
    this._buffer.filter((s) => s.traceId === traceId).forEach((s) => Object.assign(s.tags, tags));
  }
  addSessionTags(sessionId, tags) {
    logger3.debug(`Adding session tags to ${sessionId}:`, tags);
    const all = [...Object.values(this._traceBuckets).flat(), ...this._buffer];
    all.filter((s) => s.sessionId === sessionId).forEach((s) => Object.assign(s.tags, tags));
  }
  isActiveTrace(traceId) {
    return traceId in this._activeTraceCounts || traceId in this._traceBuckets;
  }
  /* FLUSH -----------------------------------------------------------------*/
  async flush() {
    if (this._buffer.length === 0)
      return;
    const spanCount = this._buffer.length;
    logger3.info(`[ZeroEval] Flushing ${spanCount} spans to backend...`);
    this._lastFlush = Date.now();
    const spansToFlush = this._buffer.splice(0);
    try {
      const startTime = Date.now();
      await this._writer.write(spansToFlush);
      const duration = Date.now() - startTime;
      logger3.info(
        `[ZeroEval] Successfully flushed ${spanCount} spans in ${duration}ms`
      );
    } catch (error) {
      logger3.error(
        `[ZeroEval] Failed to flush ${spanCount} spans:`,
        error instanceof Error ? error.message : error
      );
      this._buffer.unshift(...spansToFlush);
      throw error;
    }
  }
  async _setupAvailableIntegrations() {
    logger3.info("Checking for available integrations...");
    const available = await discoverIntegrations();
    for (const [key, Ctor] of Object.entries(available)) {
      try {
        const inst = new Ctor();
        if (Ctor.isAvailable?.() !== false) {
          logger3.info(`Setting up integration: ${key}`);
          inst.setup();
          this._integrations[key] = inst;
          logger3.info(`\u2705 Successfully set up integration: ${key}`);
        }
      } catch (err) {
        logger3.error(`\u274C Failed to setup integration ${key}:`, err);
      }
    }
    if (Object.keys(this._integrations).length > 0) {
      logger3.info(
        `Active integrations: ${Object.keys(this._integrations).join(", ")}`
      );
    } else {
      logger3.info("No active integrations found.");
    }
  }
  /** Flush remaining spans and teardown integrations */
  shutdown() {
    if (this._shuttingDown)
      return;
    this._shuttingDown = true;
    logger3.info("Shutting down tracer...");
    void this.flush().catch((error) => {
      logger3.error("[ZeroEval] Shutdown flush failed:", error);
    });
    for (const inst of Object.values(this._integrations)) {
      try {
        inst.teardown();
      } catch (error) {
        logger3.error("[ZeroEval] Integration teardown failed:", error);
      }
    }
  }
};
var tracer = new Tracer();

export {
  Span,
  Logger,
  getLogger,
  signalWriter,
  tracer
};
