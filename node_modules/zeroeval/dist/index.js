import {
  addPendingSessionSignal,
  addPendingTraceSignal
} from "./chunk-F2DR4F63.js";
import {
  LangChainIntegration
} from "./chunk-6F3NBJVJ.js";
import "./chunk-ATTYGEN4.js";
import {
  Logger,
  Span,
  getLogger,
  signalWriter,
  tracer
} from "./chunk-2VY765DQ.js";
import "./chunk-P57PW2II.js";

// src/init.ts
var logger = getLogger("zeroeval");
var initialized = false;
function isInitialized() {
  return initialized;
}
function validateInit() {
  const logger3 = getLogger("zeroeval");
  if (!process.env.ZEROEVAL_WORKSPACE_NAME || !process.env.ZEROEVAL_API_KEY) {
    logger3.error(
      "ZeroEval SDK not initialized. Please call ze.init(apiKey='YOUR_API_KEY') first."
    );
    return false;
  }
  return true;
}
function init(opts = {}) {
  const {
    apiKey,
    apiUrl,
    workspaceName = "Personal Workspace",
    flushInterval,
    maxSpans,
    collectCodeDetails,
    integrations,
    debug
  } = opts;
  const isDebugMode = debug || process.env.ZEROEVAL_DEBUG?.toLowerCase() === "true";
  if (isDebugMode) {
    process.env.ZEROEVAL_DEBUG = "true";
    Logger.setDebugMode(true);
    const maskedApiKey = Logger.maskApiKey(
      apiKey || process.env.ZEROEVAL_API_KEY
    );
    const finalApiUrl = apiUrl || process.env.ZEROEVAL_API_URL || "https://api.zeroeval.com";
    logger.debug("ZeroEval SDK Configuration:");
    logger.debug(`  Workspace: ${workspaceName}`);
    logger.debug(`  API Key: ${maskedApiKey}`);
    logger.debug(`  API URL: ${finalApiUrl}`);
    logger.debug(`  Debug Mode: ${isDebugMode}`);
    logger.debug(`  Flush Interval: ${flushInterval ?? "10s (default)"}`);
    logger.debug(`  Max Spans: ${maxSpans ?? "100 (default)"}`);
    logger.debug(
      `  Collect Code Details: ${collectCodeDetails ?? "true (default)"}`
    );
    logger.info("SDK initialized in debug mode.");
  } else {
    Logger.setDebugMode(false);
  }
  process.env.ZEROEVAL_WORKSPACE_NAME = workspaceName;
  if (apiKey)
    process.env.ZEROEVAL_API_KEY = apiKey;
  if (apiUrl)
    process.env.ZEROEVAL_API_URL = apiUrl;
  tracer.configure({
    flushInterval,
    maxSpans,
    collectCodeDetails,
    integrations
  });
  initialized = true;
}

// src/observability/spanDecorator.ts
function span(opts) {
  return function(_target, _propertyKey, descriptor) {
    if (descriptor && typeof descriptor.value === "function") {
      const original = descriptor.value;
      const isAsync = original.constructor.name === "AsyncFunction";
      const wrapper = function(...args) {
        const spanInst = tracer.startSpan(opts.name, {
          attributes: opts.attributes,
          sessionId: opts.sessionId,
          sessionName: opts.sessionName,
          tags: opts.tags
        });
        try {
          const result = original.apply(this, args);
          if (isAsync && result && typeof result.then === "function") {
            return result.then((r) => {
              if (opts.inputData === void 0) {
                const output = opts.outputData !== void 0 ? typeof opts.outputData === "string" ? opts.outputData : JSON.stringify(opts.outputData, replacer, 2) : typeof r === "string" ? r : JSON.stringify(r, replacer, 2);
                spanInst.setIO(JSON.stringify(args, replacer, 2), output);
              } else {
                const output = opts.outputData !== void 0 ? opts.outputData : r;
                spanInst.setIO(opts.inputData, output);
              }
              tracer.endSpan(spanInst);
              return r;
            }).catch((err) => {
              spanInst.setError({
                code: err?.name,
                message: err?.message,
                stack: err?.stack
              });
              tracer.endSpan(spanInst);
              throw err;
            });
          }
          if (opts.inputData === void 0) {
            const output = opts.outputData !== void 0 ? typeof opts.outputData === "string" ? opts.outputData : JSON.stringify(opts.outputData, replacer, 2) : typeof result === "string" ? result : JSON.stringify(result, replacer, 2);
            spanInst.setIO(JSON.stringify(args, replacer, 2), output);
          } else {
            const output = opts.outputData !== void 0 ? opts.outputData : result;
            spanInst.setIO(opts.inputData, output);
          }
          tracer.endSpan(spanInst);
          return result;
        } catch (err) {
          spanInst.setError({
            code: err?.name,
            message: err?.message,
            stack: err?.stack
          });
          tracer.endSpan(spanInst);
          throw err;
        }
      };
      Object.defineProperty(wrapper, "name", { value: original.name });
      descriptor.value = wrapper;
      return descriptor;
    }
  };
}
function withSpan(opts, fn) {
  const spanInst = tracer.startSpan(opts.name, {
    attributes: opts.attributes,
    sessionId: opts.sessionId,
    sessionName: opts.sessionName,
    tags: opts.tags
  });
  try {
    const result = fn();
    if (result && typeof result.then === "function") {
      return result.then((res) => {
        if (opts.inputData !== void 0 || opts.outputData !== void 0) {
          const output = opts.outputData !== void 0 ? opts.outputData : res;
          spanInst.setIO(opts.inputData, output);
        }
        tracer.endSpan(spanInst);
        return res;
      }).catch((err) => {
        spanInst.setError({
          code: err?.name,
          message: err?.message,
          stack: err?.stack
        });
        tracer.endSpan(spanInst);
        throw err;
      });
    }
    if (opts.inputData !== void 0 || opts.outputData !== void 0) {
      const output = opts.outputData !== void 0 ? opts.outputData : result;
      spanInst.setIO(opts.inputData, output);
    }
    tracer.endSpan(spanInst);
    return result;
  } catch (err) {
    spanInst.setError({
      code: err?.name,
      message: err?.message,
      stack: err?.stack
    });
    tracer.endSpan(spanInst);
    throw err;
  }
}
function replacer(_key, value) {
  if (typeof value === "bigint")
    return value.toString();
  if (typeof value === "function")
    return `[Function ${value.name || "anonymous"}]`;
  return value;
}

// src/helpers.ts
function getCurrentSpan() {
  return tracer.currentSpan();
}
function getCurrentTrace() {
  return tracer.currentSpan()?.traceId;
}
function getCurrentSession() {
  return tracer.currentSpan()?.sessionId;
}
function setTag(target, tags) {
  if (!target || !tags || typeof tags !== "object")
    return;
  if (typeof target !== "string") {
    Object.assign(target.tags, tags);
  } else {
    if (tracer.isActiveTrace(target)) {
      tracer.addTraceTags(target, tags);
    } else {
      tracer.addSessionTags(target, tags);
    }
  }
}

// src/observability/integrations/openaiWrapper.ts
function wrapOpenAI(client) {
  if (client.__zeroeval_wrapped) {
    return client;
  }
  const wrappedClient = new Proxy(client, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "__zeroeval_wrapped") {
        return true;
      }
      if (prop === "chat") {
        return new Proxy(value, {
          get(chatTarget, chatProp) {
            const chatValue = Reflect.get(chatTarget, chatProp);
            if (chatProp === "completions") {
              return new Proxy(chatValue, {
                get(completionsTarget, completionsProp) {
                  const completionsValue = Reflect.get(
                    completionsTarget,
                    completionsProp
                  );
                  if (completionsProp === "create") {
                    return wrapCompletionsCreate(
                      completionsValue.bind(completionsTarget)
                    );
                  }
                  if (completionsProp === "retrieve" || completionsProp === "update" || completionsProp === "list" || completionsProp === "delete") {
                    return wrapGenericMethod(
                      completionsValue.bind(completionsTarget),
                      `openai.chat.completions.${String(completionsProp)}`
                    );
                  }
                  return completionsValue;
                }
              });
            }
            return chatValue;
          }
        });
      }
      if (prop === "embeddings" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(embeddingsTarget, embeddingsProp) {
            const embeddingsValue = Reflect.get(
              embeddingsTarget,
              embeddingsProp
            );
            if (embeddingsProp === "create" && typeof embeddingsValue === "function") {
              return wrapGenericMethod(
                embeddingsValue.bind(embeddingsTarget),
                "openai.embeddings.create"
              );
            }
            return embeddingsValue;
          }
        });
      }
      if (prop === "images" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(imagesTarget, imagesProp) {
            const imagesValue = Reflect.get(imagesTarget, imagesProp);
            if ((imagesProp === "generate" || imagesProp === "edit" || imagesProp === "createVariation") && typeof imagesValue === "function") {
              return wrapGenericMethod(
                imagesValue.bind(imagesTarget),
                `openai.images.${String(imagesProp)}`
              );
            }
            return imagesValue;
          }
        });
      }
      if (prop === "audio" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(audioTarget, audioProp) {
            const audioValue = Reflect.get(audioTarget, audioProp);
            if ((audioProp === "transcriptions" || audioProp === "translations") && typeof audioValue === "object" && audioValue !== null) {
              return new Proxy(audioValue, {
                get(subTarget, subProp) {
                  const subValue = Reflect.get(subTarget, subProp);
                  if (subProp === "create" && typeof subValue === "function") {
                    return wrapGenericMethod(
                      subValue.bind(subTarget),
                      `openai.audio.${String(audioProp)}.create`
                    );
                  }
                  return subValue;
                }
              });
            }
            return audioValue;
          }
        });
      }
      return value;
    }
  });
  return wrappedClient;
}
function wrapCompletionsCreate(originalMethod) {
  return async function wrappedCreate(...args) {
    const [params] = args;
    const isStreaming = !!params?.stream;
    const startTime = Date.now() / 1e3;
    if (isStreaming && params?.model && typeof params.model === "string" && !params.model.includes("/")) {
      params.stream_options = { include_usage: true };
    }
    const serializedMessages = params?.messages ? params.messages.map((msg) => ({
      role: msg.role,
      content: msg.content
    })) : [];
    const span2 = tracer.startSpan("openai.chat.completions.create", {
      attributes: {
        "service.name": "openai",
        kind: "llm",
        provider: "openai",
        model: params?.model,
        messages: serializedMessages,
        streaming: isStreaming
      },
      tags: { integration: "openai" }
    });
    try {
      const result = await originalMethod(...args);
      if (isStreaming && result && typeof result[Symbol.asyncIterator] === "function") {
        return wrapStream(result, span2, serializedMessages, startTime);
      }
      if (!isStreaming && result) {
        const elapsed = Date.now() / 1e3 - startTime;
        const output = result.choices?.[0]?.message?.content || "";
        if (result.usage) {
          span2.attributes.inputTokens = result.usage.prompt_tokens;
          span2.attributes.outputTokens = result.usage.completion_tokens;
        }
        const throughput = output.length > 0 && elapsed > 0 ? Math.round(output.length / elapsed * 100) / 100 : 0;
        span2.attributes.throughput = throughput;
        span2.setIO(JSON.stringify(serializedMessages), output);
      }
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
}
function wrapGenericMethod(originalMethod, spanName) {
  return async function wrappedMethod(...args) {
    const [params] = args;
    let kind = "operation";
    if (spanName.includes("embeddings")) {
      kind = "embedding";
    }
    const span2 = tracer.startSpan(spanName, {
      attributes: {
        "service.name": "openai",
        kind,
        provider: "openai",
        ...params?.model && { model: params.model }
      },
      tags: { integration: "openai" }
    });
    try {
      const result = await originalMethod(...args);
      let output;
      if (result?.data && Array.isArray(result.data)) {
        output = `${result.data.length} items`;
      } else if (result?.text) {
        output = result.text;
      } else if (result?.embedding) {
        output = `embedding[${result.embedding.length}]`;
      } else {
        output = JSON.stringify(result);
      }
      span2.setIO(JSON.stringify(params), output);
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
}
async function* wrapStream(stream, span2, serializedMessages, startTime) {
  const chunks = [];
  let errorOccurred = false;
  let firstTokenTime = null;
  let fullResponse = "";
  try {
    for await (const chunk of stream) {
      if (!chunk.choices && chunk.usage) {
        span2.attributes.inputTokens = chunk.usage.prompt_tokens;
        span2.attributes.outputTokens = chunk.usage.completion_tokens;
        chunks.push(chunk);
        yield chunk;
        continue;
      }
      if (chunk.choices?.[0]?.delta?.content) {
        const content = chunk.choices[0].delta.content;
        if (firstTokenTime === null) {
          firstTokenTime = Date.now() / 1e3;
          span2.attributes.latency = Math.round((firstTokenTime - startTime) * 1e4) / 1e4;
        }
        fullResponse += content;
      }
      chunks.push(chunk);
      yield chunk;
    }
    const elapsed = Date.now() / 1e3 - startTime;
    const throughput = fullResponse.length > 0 && elapsed > 0 ? Math.round(fullResponse.length / elapsed * 100) / 100 : 0;
    span2.attributes.throughput = throughput;
    span2.setIO(JSON.stringify(serializedMessages), fullResponse);
  } catch (error) {
    errorOccurred = true;
    span2.setError({
      code: error?.name || "StreamError",
      message: error?.message || "Stream error occurred",
      stack: error?.stack
    });
    throw error;
  } finally {
    if (!errorOccurred) {
      tracer.endSpan(span2);
    }
  }
}

// src/observability/integrations/vercelAIWrapper.ts
function wrapVercelAIFunction(fn, functionName) {
  if (fn.__zeroeval_wrapped) {
    return fn;
  }
  if (!isInitialized()) {
    const envApiKey = process.env.ZEROEVAL_API_KEY;
    if (envApiKey) {
      init({ apiKey: envApiKey });
    }
  }
  const wrappedFn = async function wrappedVercelAIFunction(...args) {
    const [options] = args;
    const model = options?.model?.modelId || options?.model || "unknown";
    const messages = options?.messages;
    const prompt = options?.prompt;
    const tools = options?.tools;
    const maxSteps = options?.maxSteps;
    const maxRetries = options?.maxRetries;
    const temperature = options?.temperature;
    const maxTokens = options?.maxTokens;
    let kind = "operation";
    if (functionName === "generateText" || functionName === "streamText") {
      kind = "llm";
    } else if (functionName === "generateObject" || functionName === "streamObject") {
      kind = "llm";
    } else if (functionName === "embed" || functionName === "embedMany") {
      kind = "embedding";
    } else if (functionName === "generateImage") {
      kind = "image";
    } else if (functionName === "generateSpeech") {
      kind = "speech";
    } else if (functionName === "transcribe") {
      kind = "transcription";
    }
    const span2 = tracer.startSpan(`vercelai.${functionName}`, {
      attributes: {
        "service.name": "vercel-ai-sdk",
        kind,
        provider: "vercel-ai-sdk",
        model,
        ...messages && { messages },
        ...temperature !== void 0 && { temperature },
        ...maxTokens !== void 0 && { maxTokens },
        ...maxSteps !== void 0 && { maxSteps },
        ...maxRetries !== void 0 && { maxRetries },
        ...tools && { toolCount: Object.keys(tools).length },
        ...functionName.includes("stream") && { streaming: true }
      },
      tags: { integration: "vercel-ai-sdk" }
    });
    const startTime = Date.now() / 1e3;
    try {
      let input;
      if (messages) {
        input = JSON.stringify(messages);
      } else if (prompt) {
        input = typeof prompt === "string" ? prompt : JSON.stringify(prompt);
      } else {
        input = JSON.stringify(options);
      }
      const result = await fn(...args);
      if (result && typeof result === "object") {
        const elapsed = Date.now() / 1e3 - startTime;
        if ("text" in result) {
          const output = result.text || "";
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
            span2.attributes.outputTokens = result.usage.completionTokens;
          }
          const throughput = output.length > 0 && elapsed > 0 ? Math.round(output.length / elapsed * 100) / 100 : 0;
          span2.attributes.throughput = throughput;
          span2.setIO(input, String(output));
        } else if ("textStream" in result || "fullStream" in result) {
          return wrapStreamingResult(result, span2, input, startTime);
        } else if ("object" in result) {
          const output = result.object ? JSON.stringify(result.object) : "{}";
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
            span2.attributes.outputTokens = result.usage.completionTokens;
          }
          span2.setIO(input, output);
        } else if ("embedding" in result || "embeddings" in result) {
          const embeddingCount = result.embeddings?.length || 1;
          const output = `${embeddingCount} embedding(s) generated`;
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
          }
          span2.setIO(input, output);
        } else {
          span2.setIO(input, JSON.stringify(result));
        }
      } else {
        span2.setIO(input, String(result || ""));
      }
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
  wrappedFn.__zeroeval_wrapped = true;
  Object.defineProperty(wrappedFn, "name", { value: fn.name });
  Object.setPrototypeOf(wrappedFn, Object.getPrototypeOf(fn));
  return wrappedFn;
}
function wrapStreamingResult(result, span2, input, startTime) {
  return new Proxy(result, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "textStream" && value && typeof value[Symbol.asyncIterator] === "function") {
        return wrapAsyncIterator(value, span2, input, startTime, "text");
      }
      if (prop === "fullStream" && value && typeof value[Symbol.asyncIterator] === "function") {
        return wrapAsyncIterator(value, span2, input, startTime, "full");
      }
      if (prop === "consumeStream") {
        return async function() {
          try {
            const full = receiver.fullStream;
            const text = receiver.textStream;
            if (full && typeof full[Symbol.asyncIterator] === "function") {
              for await (const _ of full) {
              }
            } else if (text && typeof text[Symbol.asyncIterator] === "function") {
              for await (const _ of text) {
              }
            }
            try {
              tracer.endSpan(span2);
            } catch {
            }
          } catch (error) {
            span2.setError({
              code: error?.name || "StreamError",
              message: error?.message || "Stream error occurred",
              stack: error?.stack
            });
            try {
              tracer.endSpan(span2);
            } catch {
            }
            throw error;
          }
        };
      }
      if (prop === "toDataStreamResponse" && typeof value === "function") {
        return async function(...args) {
          const response = await value.apply(target, args);
          tracer.endSpan(span2);
          return response;
        };
      }
      if (prop === "toAIStreamResponse" && typeof value === "function") {
        return async function(...args) {
          const response = await value.apply(target, args);
          tracer.endSpan(span2);
          return response;
        };
      }
      if (prop === "toDataStream" && typeof value === "function") {
        return async function(...args) {
          const stream = await value.apply(target, args);
          tracer.endSpan(span2);
          return stream;
        };
      }
      return value;
    }
  });
}
async function* wrapAsyncIterator(iterator, span2, input, startTime, streamType) {
  let fullText = "";
  let chunkCount = 0;
  let tokenCount = 0;
  let firstTokenTime = null;
  try {
    for await (const chunk of iterator) {
      chunkCount++;
      if (firstTokenTime === null && (streamType === "text" && chunk || streamType === "full" && (chunk.type === "text-delta" || chunk.type === "text"))) {
        firstTokenTime = Date.now() / 1e3;
        span2.attributes.latency = Math.round((firstTokenTime - startTime) * 1e4) / 1e4;
      }
      if (streamType === "text" && typeof chunk === "string") {
        fullText += chunk;
      } else if (streamType === "full" && chunk) {
        if (chunk.type === "text-delta" && chunk.textDelta) {
          fullText += chunk.textDelta;
        } else if (chunk.type === "text" && chunk.text) {
          fullText += chunk.text;
        }
        if (chunk.usage) {
          tokenCount = chunk.usage.completionTokens || tokenCount;
          if (chunk.usage.promptTokens) {
            span2.attributes.inputTokens = chunk.usage.promptTokens;
          }
        }
      }
      yield chunk;
    }
    const elapsed = Date.now() / 1e3 - startTime;
    const throughput = fullText.length > 0 && elapsed > 0 ? Math.round(fullText.length / elapsed * 100) / 100 : 0;
    span2.attributes.throughput = throughput;
    span2.attributes.chunkCount = chunkCount;
    if (tokenCount > 0) {
      span2.attributes.outputTokens = tokenCount;
    }
    span2.setIO(input, fullText || "");
    tracer.endSpan(span2);
  } catch (error) {
    span2.setError({
      code: error?.name || "StreamError",
      message: error?.message || "An error occurred during streaming",
      stack: error?.stack
    });
    tracer.endSpan(span2);
    throw error;
  }
}
function wrapVercelAI(aiModule) {
  if (aiModule.__zeroeval_wrapped) {
    return aiModule;
  }
  const functionsToWrap = [
    "generateText",
    "streamText",
    "generateObject",
    "streamObject",
    "embed",
    "embedMany",
    "generateImage",
    "transcribe",
    "generateSpeech"
  ];
  const wrappedModule = {};
  for (const key in aiModule) {
    const value = aiModule[key];
    if (functionsToWrap.includes(key) && typeof value === "function") {
      wrappedModule[key] = wrapVercelAIFunction(value, key);
    } else {
      wrappedModule[key] = value;
    }
  }
  wrappedModule.__zeroeval_wrapped = true;
  Object.setPrototypeOf(wrappedModule, Object.getPrototypeOf(aiModule));
  return wrappedModule;
}

// src/observability/integrations/wrapper.ts
function isOpenAIClient(client) {
  if (typeof client !== "object" || client === null) {
    return false;
  }
  const obj = client;
  return obj.chat !== void 0 && typeof obj.chat === "object" && obj.chat !== null && "completions" in obj.chat && obj.embeddings !== void 0 && typeof obj.embeddings === "object" && obj.embeddings !== null && "create" in obj.embeddings && obj.constructor !== void 0 && typeof obj.constructor === "function" && obj.constructor.name === "OpenAI";
}
function isVercelAIModule(client) {
  if (typeof client !== "object" || client === null) {
    return false;
  }
  const obj = client;
  return typeof obj.generateText === "function" || typeof obj.streamText === "function" || typeof obj.generateObject === "function" || typeof obj.embed === "function";
}
function wrap(client) {
  if (client.__zeroeval_wrapped) {
    return client;
  }
  if (!isInitialized()) {
    const envApiKey = process.env.ZEROEVAL_API_KEY;
    if (envApiKey) {
      init({ apiKey: envApiKey });
    }
  }
  if (isOpenAIClient(client)) {
    return wrapOpenAI(client);
  }
  if (isVercelAIModule(client)) {
    return wrapVercelAI(client);
  }
  let clientType = "unknown";
  if (typeof client === "object" && client !== null) {
    const obj = client;
    if (obj.constructor && typeof obj.constructor === "function") {
      const ctor = obj.constructor;
      clientType = ctor.name || "unknown";
    }
  } else {
    clientType = typeof client;
  }
  throw new Error(
    `Unsupported client type. ze.wrap() currently supports:
- OpenAI clients (from 'openai' package)
- Vercel AI SDK (from 'ai' package)

Received: ${clientType}

Make sure you're passing a valid client instance, e.g.:
  const openai = ze.wrap(new OpenAI());
  const ai = ze.wrap(await import('ai'));`
  );
}

// src/observability/signals.ts
function detectSignalType(value) {
  if (typeof value === "boolean") {
    return "boolean";
  }
  if (typeof value === "number") {
    return "numerical";
  }
  const strVal = String(value).toLowerCase();
  if (strVal === "true" || strVal === "false") {
    return "boolean";
  }
  const num = Number(value);
  if (!isNaN(num)) {
    return "numerical";
  }
  return "boolean";
}

// src/signals.ts
var logger2 = getLogger("zeroeval.signals");
async function sendSignal(entityType, entityId, name, value, signalType) {
  const signal = {
    entity_type: entityType,
    entity_id: entityId,
    name,
    value,
    signal_type: signalType || detectSignalType(value)
  };
  await signalWriter.createSignal(signal);
}
async function sendBulkSignals(signals) {
  await signalWriter.createBulkSignals(signals);
}
function sendTraceSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan) {
    logger2.warn(
      "[ZeroEval] No active span/trace found for sending trace signal"
    );
    return;
  }
  const sig = {
    value,
    type: signalType || detectSignalType(value)
  };
  addPendingTraceSignal(currentSpan.traceId, name, sig);
}
function sendSessionSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan || !currentSpan.sessionId) {
    logger2.warn(
      "[ZeroEval] No active session found for sending session signal"
    );
    return;
  }
  const sig = {
    value,
    type: signalType || detectSignalType(value)
  };
  addPendingSessionSignal(currentSpan.sessionId, name, sig);
}
function sendSpanSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan) {
    logger2.warn("[ZeroEval] No active span found for sending span signal");
    return;
  }
  currentSpan.addSignal(name, value, signalType);
}
async function getEntitySignals(entityType, entityId) {
  const result = await signalWriter.getEntitySignals(
    entityType,
    entityId
  );
  if (!result || !Array.isArray(result)) {
    return [];
  }
  return result;
}
export {
  LangChainIntegration,
  Span,
  getCurrentSession,
  getCurrentSpan,
  getCurrentTrace,
  getEntitySignals,
  init,
  isInitialized,
  sendBulkSignals,
  sendSessionSignal,
  sendSignal,
  sendSpanSignal,
  sendTraceSignal,
  setTag,
  span,
  tracer,
  validateInit,
  withSpan,
  wrap,
  wrapOpenAI,
  wrapVercelAI
};
