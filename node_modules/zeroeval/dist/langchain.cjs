"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/observability/Span.ts
var import_crypto, Span;
var init_Span = __esm({
  "src/observability/Span.ts"() {
    "use strict";
    import_crypto = require("crypto");
    Span = class {
      constructor(name, traceId) {
        this.spanId = (0, import_crypto.randomUUID)();
        this.startTime = Date.now();
        this.attributes = {};
        this.tags = {};
        this.traceTags = {};
        this.sessionTags = {};
        this.signals = {};
        this.status = "ok";
        this.name = name;
        this.traceId = traceId ?? (0, import_crypto.randomUUID)();
      }
      end() {
        this.endTime = Date.now();
      }
      get durationMs() {
        return this.endTime ? this.endTime - this.startTime : void 0;
      }
      setError(info) {
        this.error = info;
        this.status = "error";
      }
      setIO(input, output) {
        if (input !== void 0) {
          this.inputData = typeof input === "string" ? input : JSON.stringify(input);
        }
        if (output !== void 0) {
          this.outputData = typeof output === "string" ? output : JSON.stringify(output);
        }
      }
      addSignal(name, value, type) {
        let signalType = type;
        if (!signalType) {
          if (typeof value === "boolean") {
            signalType = "boolean";
          } else if (typeof value === "number") {
            signalType = "numerical";
          } else {
            const strVal = String(value).toLowerCase();
            if (strVal === "true" || strVal === "false") {
              signalType = "boolean";
            } else if (!isNaN(Number(value))) {
              signalType = "numerical";
            } else {
              signalType = "boolean";
            }
          }
        }
        this.signals[name] = {
          value,
          type: signalType
        };
      }
      toJSON() {
        return {
          span_id: this.spanId,
          trace_id: this.traceId,
          parent_id: this.parentId,
          name: this.name,
          start_time: new Date(this.startTime).toISOString(),
          end_time: this.endTime ? new Date(this.endTime).toISOString() : void 0,
          duration_ms: this.durationMs,
          session_id: this.sessionId,
          session_name: this.sessionName,
          attributes: this.attributes,
          tags: this.tags,
          trace_tags: this.traceTags,
          session_tags: this.sessionTags,
          signals: this.signals,
          input_data: this.inputData,
          output_data: this.outputData,
          error_code: this.error?.code,
          error_message: this.error?.message,
          error_stack: this.error?.stack,
          status: this.status
        };
      }
    };
  }
});

// src/observability/logger.ts
function getLogger(name) {
  return new Logger(name);
}
var colors, _Logger, Logger;
var init_logger = __esm({
  "src/observability/logger.ts"() {
    "use strict";
    colors = {
      grey: "\x1B[38;5;244m",
      blue: "\x1B[34;1m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      red: "\x1B[31m",
      boldRed: "\x1B[31;1m",
      reset: "\x1B[0m"
    };
    _Logger = class _Logger {
      constructor(name) {
        this.name = name;
      }
      static setDebugMode(enabled) {
        _Logger.isDebugMode = enabled;
        _Logger.globalLevel = enabled ? 0 /* DEBUG */ : 2 /* WARN */;
        _Logger.bufferEarlyLogs = false;
        if (enabled && _Logger.earlyLogs.length > 0) {
          console.log("[zeroeval] Replaying buffered debug logs...");
          for (const log of _Logger.earlyLogs) {
            if (_Logger.globalLevel <= log.level) {
              const fn = log.level <= 1 /* INFO */ ? console.log : console.error;
              fn(
                log.logger.formatMessage(
                  log.levelName,
                  log.levelColor,
                  log.message
                ),
                ...log.args
              );
            }
          }
          _Logger.earlyLogs = [];
        }
      }
      static isDebugEnabled() {
        return _Logger.isDebugMode;
      }
      formatTimestamp() {
        const now = /* @__PURE__ */ new Date();
        const hours = now.getHours().toString().padStart(2, "0");
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const seconds = now.getSeconds().toString().padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }
      formatMessage(level, levelColor, message) {
        if (!_Logger.isDebugMode) {
          return `[${this.name}] [${level}] ${message}`;
        }
        const timestamp = this.formatTimestamp();
        return `${colors.grey}[${timestamp}]${colors.reset} ${colors.blue}[${this.name}]${colors.reset} ${levelColor}[${level}]${colors.reset} ${message}`;
      }
      debug(message, ...args) {
        if (_Logger.bufferEarlyLogs && 0 /* DEBUG */ >= _Logger.globalLevel) {
          _Logger.earlyLogs.push({
            logger: this,
            level: 0 /* DEBUG */,
            levelName: "DEBUG",
            levelColor: colors.blue,
            message,
            args
          });
          return;
        }
        if (_Logger.globalLevel <= 0 /* DEBUG */) {
          console.log(this.formatMessage("DEBUG", colors.blue, message), ...args);
        }
      }
      info(message, ...args) {
        if (_Logger.bufferEarlyLogs && 1 /* INFO */ >= _Logger.globalLevel) {
          _Logger.earlyLogs.push({
            logger: this,
            level: 1 /* INFO */,
            levelName: "INFO",
            levelColor: colors.green,
            message,
            args
          });
          return;
        }
        if (_Logger.globalLevel <= 1 /* INFO */) {
          console.log(this.formatMessage("INFO", colors.green, message), ...args);
        }
      }
      warn(message, ...args) {
        if (_Logger.globalLevel <= 2 /* WARN */) {
          console.warn(this.formatMessage("WARN", colors.yellow, message), ...args);
        }
      }
      error(message, ...args) {
        if (_Logger.globalLevel <= 3 /* ERROR */) {
          console.error(this.formatMessage("ERROR", colors.red, message), ...args);
        }
      }
      critical(message, ...args) {
        if (_Logger.globalLevel <= 4 /* CRITICAL */) {
          console.error(
            this.formatMessage("CRITICAL", colors.boldRed, message),
            ...args
          );
        }
      }
      /**
       * Mask sensitive data like API keys for logging
       */
      static maskApiKey(apiKey) {
        if (!apiKey)
          return "Not set";
        if (apiKey.length <= 8)
          return "***";
        return `${apiKey.substring(0, 8)}...`;
      }
    };
    _Logger.globalLevel = 2 /* WARN */;
    _Logger.isDebugMode = false;
    _Logger.earlyLogs = [];
    _Logger.bufferEarlyLogs = true;
    Logger = _Logger;
  }
});

// src/observability/signalWriter.ts
var logger, SignalWriter, signalWriter;
var init_signalWriter = __esm({
  "src/observability/signalWriter.ts"() {
    "use strict";
    init_logger();
    logger = getLogger("zeroeval.signalWriter");
    SignalWriter = class {
      getApiUrl() {
        return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
          /\/$/,
          ""
        );
      }
      getApiKey() {
        return process.env.ZEROEVAL_API_KEY;
      }
      /**
       * Send a single signal to the backend
       */
      async createSignal(signal) {
        const endpoint = `${this.getApiUrl()}/signals/`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        logger.debug(`[ZeroEval] Sending signal to ${endpoint}`);
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger.debug("[ZeroEval] Request body:", JSON.stringify(signal, null, 2));
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(signal)
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed creating signal: ${res.status} ${text}`
            );
            return {
              status: "error",
              message: `Failed to create signal: ${res.status} ${text}`
            };
          }
          logger.info(
            `[ZeroEval] Successfully created signal for ${signal.entity_type}:${signal.entity_id} - ${signal.name}`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error creating signal", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              signal,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return {
            status: "error",
            message: `Error creating signal: ${err instanceof Error ? err.message : String(err)}`
          };
        }
      }
      /**
       * Send multiple signals to the backend in bulk
       */
      async createBulkSignals(signals) {
        const endpoint = `${this.getApiUrl()}/signals/bulk`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        const bulkRequest = { signals };
        logger.debug(
          `[ZeroEval] Sending ${signals.length} bulk signals to ${endpoint}`
        );
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger.debug(
            "[ZeroEval] Request body:",
            JSON.stringify(bulkRequest, null, 2)
          );
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(bulkRequest)
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed creating bulk signals: ${res.status} ${text}`
            );
            return {
              status: "error",
              message: `Failed to create bulk signals: ${res.status} ${text}`
            };
          }
          logger.info(
            `[ZeroEval] Successfully created ${signals.length} bulk signals`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error creating bulk signals", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              signalCount: signals.length,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return {
            status: "error",
            message: `Error creating bulk signals: ${err instanceof Error ? err.message : String(err)}`
          };
        }
      }
      /**
       * Get all signals for a specific entity
       */
      async getEntitySignals(entityType, entityId) {
        const endpoint = `${this.getApiUrl()}/signals/entity/${entityType}/${entityId}`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        logger.debug(
          `[ZeroEval] Getting signals for ${entityType}:${entityId} from ${endpoint}`
        );
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "GET",
            headers
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed getting entity signals: ${res.status} ${text}`
            );
            return null;
          }
          logger.info(
            `[ZeroEval] Successfully retrieved signals for ${entityType}:${entityId}`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error getting entity signals", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              entityType,
              entityId,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return null;
        }
      }
    };
    signalWriter = new SignalWriter();
  }
});

// src/observability/pendingSignals.ts
var pendingSignals_exports = {};
__export(pendingSignals_exports, {
  addPendingSessionSignal: () => addPendingSessionSignal,
  addPendingTraceSignal: () => addPendingTraceSignal,
  popPendingSessionSignals: () => popPendingSessionSignals,
  popPendingTraceSignals: () => popPendingTraceSignals
});
function addPendingTraceSignal(traceId, name, signal) {
  const bucket = traceBuffer[traceId] || (traceBuffer[traceId] = {});
  bucket[name] = signal;
}
function popPendingTraceSignals(traceId) {
  const sigs = traceBuffer[traceId];
  if (sigs)
    delete traceBuffer[traceId];
  return sigs;
}
function addPendingSessionSignal(sessionId, name, signal) {
  const bucket = sessionBuffer[sessionId] || (sessionBuffer[sessionId] = {});
  bucket[name] = signal;
}
function popPendingSessionSignals(sessionId) {
  const sigs = sessionBuffer[sessionId];
  if (sigs)
    delete sessionBuffer[sessionId];
  return sigs;
}
var traceBuffer, sessionBuffer;
var init_pendingSignals = __esm({
  "src/observability/pendingSignals.ts"() {
    "use strict";
    traceBuffer = {};
    sessionBuffer = {};
  }
});

// src/observability/writer.ts
var logger2, BackendSpanWriter;
var init_writer = __esm({
  "src/observability/writer.ts"() {
    "use strict";
    init_signalWriter();
    init_logger();
    logger2 = getLogger("zeroeval.writer");
    BackendSpanWriter = class {
      getApiUrl() {
        return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
          /\/$/,
          ""
        );
      }
      getApiKey() {
        return process.env.ZEROEVAL_API_KEY;
      }
      async write(spans) {
        if (!spans.length)
          return;
        const endpoint = `${this.getApiUrl()}/spans`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        const spansWithSignals = [];
        const traceIds = /* @__PURE__ */ new Set();
        const sessionIds = /* @__PURE__ */ new Set();
        const payload = spans.map((s) => {
          const base = typeof s.toJSON === "function" ? s.toJSON() : s;
          if (base.signals && Object.keys(base.signals).length > 0) {
            spansWithSignals.push({ spanId: base.span_id, signals: base.signals });
          }
          traceIds.add(base.trace_id);
          if (base.session_id)
            sessionIds.add(base.session_id);
          return {
            id: base.span_id,
            session_id: base.session_id,
            session_name: base.session_name,
            trace_id: base.trace_id,
            parent_span_id: base.parent_id,
            name: base.name,
            started_at: base.start_time,
            ended_at: base.end_time,
            duration_ms: base.duration_ms,
            attributes: base.attributes,
            status: base.status,
            input_data: base.input_data,
            output_data: base.output_data,
            code: base.code ?? base.attributes?.code,
            code_filepath: base.code_filepath ?? base.attributes?.code_filepath,
            code_lineno: base.code_lineno ?? base.attributes?.code_lineno,
            error_code: base.error_code,
            error_message: base.error_message,
            error_stack: String(base.error_stack ?? ""),
            tags: base.tags,
            trace_tags: base.trace_tags,
            session_tags: base.session_tags
          };
        });
        logger2.debug(`[ZeroEval] Sending ${payload.length} spans to ${endpoint}`);
        if (Logger.isDebugEnabled()) {
          logger2.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger2.debug(
            "[ZeroEval] Request body:",
            JSON.stringify(payload, null, 2)
          );
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          });
          const duration = Date.now() - startTime;
          logger2.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger2.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger2.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger2.error(`[ZeroEval] Failed posting spans: ${res.status} ${text}`);
          } else {
            logger2.info(
              `[ZeroEval] Successfully posted ${payload.length} spans to ${endpoint}`
            );
            await this.sendSpanSignals(spansWithSignals);
            await this.flushTraceSessionSignals(
              Array.from(traceIds),
              Array.from(sessionIds)
            );
          }
        } catch (err) {
          logger2.error("[ZeroEval] Error posting spans", err);
          if (Logger.isDebugEnabled()) {
            logger2.debug("[ZeroEval] Error details:", {
              endpoint,
              spanCount: payload.length,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
        }
      }
      async sendSpanSignals(spansWithSignals) {
        if (spansWithSignals.length === 0)
          return;
        const bulkSignals = [];
        for (const { spanId, signals } of spansWithSignals) {
          for (const [name, signal] of Object.entries(signals)) {
            bulkSignals.push({
              entity_type: "span",
              entity_id: spanId,
              name,
              value: signal.value,
              signal_type: signal.type
            });
          }
        }
        if (bulkSignals.length > 0) {
          try {
            await signalWriter.createBulkSignals(bulkSignals);
          } catch (err) {
            logger2.error("[ZeroEval] Error sending span signals", err);
          }
        }
      }
      async flushTraceSessionSignals(traceIds, sessionIds) {
        if (traceIds.length === 0 && sessionIds.length === 0)
          return;
        const { popPendingTraceSignals: popPendingTraceSignals2, popPendingSessionSignals: popPendingSessionSignals2 } = await Promise.resolve().then(() => (init_pendingSignals(), pendingSignals_exports));
        const bulk = [];
        for (const tid of traceIds) {
          const signals = popPendingTraceSignals2(tid);
          if (!signals)
            continue;
          for (const [name, sig] of Object.entries(signals)) {
            bulk.push({
              entity_type: "trace",
              entity_id: tid,
              name,
              value: sig.value,
              signal_type: sig.type
            });
          }
        }
        for (const sid of sessionIds) {
          const signals = popPendingSessionSignals2(sid);
          if (!signals)
            continue;
          for (const [name, sig] of Object.entries(signals)) {
            bulk.push({
              entity_type: "session",
              entity_id: sid,
              name,
              value: sig.value,
              signal_type: sig.type
            });
          }
        }
        if (bulk.length > 0) {
          try {
            await signalWriter.createBulkSignals(bulk);
          } catch (err) {
            logger2.error("[ZeroEval] Error posting trace/session signals", err);
          }
        }
      }
    };
  }
});

// src/observability/integrations/base.ts
var _Integration, Integration;
var init_base = __esm({
  "src/observability/integrations/base.ts"() {
    "use strict";
    _Integration = class _Integration {
      constructor() {
        this.originals = /* @__PURE__ */ new Map();
      }
      patchMethod(obj, key, build) {
        const orig = obj[key];
        if (typeof orig !== "function" || orig[_Integration.PATCHED])
          return;
        const wrapped = build(orig);
        wrapped[_Integration.PATCHED] = true;
        if (!this.originals.has(obj))
          this.originals.set(obj, /* @__PURE__ */ new Map());
        this.originals.get(obj).set(key, orig);
        obj[key] = wrapped;
      }
      teardown() {
        for (const [obj, map] of this.originals.entries()) {
          for (const [k, fn] of map) {
            obj[k] = fn;
          }
        }
        this.originals = /* @__PURE__ */ new Map();
      }
    };
    _Integration.PATCHED = Symbol("zePatched");
    Integration = _Integration;
  }
});

// src/observability/integrations/langchain.ts
var langchain_exports = {};
__export(langchain_exports, {
  LangChainIntegration: () => LangChainIntegration
});
var LangChainIntegration;
var init_langchain = __esm({
  "src/observability/integrations/langchain.ts"() {
    "use strict";
    init_base();
    init_Tracer();
    LangChainIntegration = class extends Integration {
      static isAvailable() {
        try {
          require.resolve("langchain");
          return true;
        } catch (_) {
          try {
            require.resolve("langchain-core");
            return true;
          } catch {
            return false;
          }
        }
      }
      async setup() {
        let mod;
        try {
          mod = await import("langchain");
        } catch {
          try {
            mod = await import("langchain-core");
          } catch {
            return;
          }
        }
        const Runnable = mod.Runnable ?? mod.RunnableBase ?? mod.RunnableSequence ?? void 0;
        if (!Runnable)
          return;
        const methods = [
          "invoke",
          "ainvoke",
          "stream",
          "astream",
          "batch",
          "abatch"
        ];
        for (const method of methods) {
          if (typeof Runnable.prototype[method] !== "function")
            continue;
          this.patchMethod(
            Runnable.prototype,
            method,
            (orig) => {
              const isAsync = method.toString().startsWith("a");
              const name = `langchain.${String(method)}`;
              if (isAsync) {
                return async function patched(...args) {
                  const className = this?.constructor?.name;
                  const attrs = {
                    class: className,
                    method: String(method)
                  };
                  if (typeof className === "string" && className.includes("ChatOpenAI")) {
                    attrs.kind = "llm";
                    attrs.provider = "openai";
                    attrs["service.name"] = "openai";
                  }
                  const span = tracer.startSpan(name, {
                    attributes: attrs,
                    tags: { integration: "langchain" }
                  });
                  try {
                    const res = await orig.apply(this, args);
                    span.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                    tracer.endSpan(span);
                    return res;
                  } catch (err) {
                    span.setError({
                      code: err?.name,
                      message: err?.message,
                      stack: err?.stack
                    });
                    tracer.endSpan(span);
                    throw err;
                  }
                };
              }
              return function patched(...args) {
                const className = this?.constructor?.name;
                const attrs = {
                  class: className,
                  method: String(method)
                };
                if (typeof className === "string" && className.includes("ChatOpenAI")) {
                  attrs.kind = "llm";
                  attrs.provider = "openai";
                  attrs["service.name"] = "openai";
                }
                const span = tracer.startSpan(name, {
                  attributes: attrs,
                  tags: { integration: "langchain" }
                });
                try {
                  const res = orig.apply(this, args);
                  if (res?.then) {
                    return res.then((r) => {
                      span.setIO(JSON.stringify(args[0]), JSON.stringify(r));
                      tracer.endSpan(span);
                      return r;
                    }).catch((err) => {
                      span.setError({
                        code: err?.name,
                        message: err?.message,
                        stack: err?.stack
                      });
                      tracer.endSpan(span);
                      throw err;
                    });
                  }
                  span.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                  tracer.endSpan(span);
                  return res;
                } catch (err) {
                  span.setError({
                    code: err?.name,
                    message: err?.message,
                    stack: err?.stack
                  });
                  tracer.endSpan(span);
                  throw err;
                }
              };
            }
          );
        }
      }
    };
  }
});

// src/observability/integrations/langgraph.ts
var langgraph_exports = {};
__export(langgraph_exports, {
  LangGraphIntegration: () => LangGraphIntegration
});
var LangGraphIntegration;
var init_langgraph = __esm({
  "src/observability/integrations/langgraph.ts"() {
    "use strict";
    init_base();
    init_Tracer();
    LangGraphIntegration = class extends Integration {
      static isAvailable() {
        try {
          require.resolve("langgraph");
          return true;
        } catch (_) {
          return false;
        }
      }
      async setup() {
        let mod;
        try {
          mod = await import("langgraph");
        } catch {
          return;
        }
        const Graph = mod.Graph ?? mod.StateGraph ?? void 0;
        if (!Graph)
          return;
        const patchInvoke = (obj) => {
          ["invoke", "ainvoke"].forEach((method) => {
            if (typeof obj.prototype[method] !== "function")
              return;
            this.patchMethod(obj.prototype, method, (orig) => {
              const isAsync = method.startsWith("a");
              const name = `langgraph.${method}`;
              if (isAsync) {
                return async function patched(...args) {
                  const span = tracer.startSpan(name, {
                    attributes: { class: this?.constructor?.name },
                    tags: { integration: "langgraph" }
                  });
                  try {
                    const res = await orig.apply(this, args);
                    span.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                    tracer.endSpan(span);
                    return res;
                  } catch (err) {
                    span.setError({
                      code: err?.name,
                      message: err?.message,
                      stack: err?.stack
                    });
                    tracer.endSpan(span);
                    throw err;
                  }
                };
              }
              return function patched(...args) {
                const span = tracer.startSpan(name, {
                  attributes: { class: this?.constructor?.name },
                  tags: { integration: "langgraph" }
                });
                try {
                  const res = orig.apply(this, args);
                  if (res?.then) {
                    return res.then((r) => {
                      span.setIO(JSON.stringify(args[0]), JSON.stringify(r));
                      tracer.endSpan(span);
                      return r;
                    }).catch((err) => {
                      span.setError({
                        code: err?.name,
                        message: err?.message,
                        stack: err?.stack
                      });
                      tracer.endSpan(span);
                      throw err;
                    });
                  }
                  span.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                  tracer.endSpan(span);
                  return res;
                } catch (err) {
                  span.setError({
                    code: err?.name,
                    message: err?.message,
                    stack: err?.stack
                  });
                  tracer.endSpan(span);
                  throw err;
                }
              };
            });
          });
        };
        patchInvoke(Graph);
        if (Graph.prototype?.compile) {
          this.patchMethod(Graph.prototype, "compile", (orig) => {
            return function patched(...args) {
              const compiled = orig.apply(this, args);
              patchInvoke(compiled.constructor);
              return compiled;
            };
          });
        }
      }
    };
  }
});

// src/observability/integrations/utils.ts
async function discoverIntegrations() {
  const integrations = {};
  try {
    await import("langchain");
    const { LangChainIntegration: LangChainIntegration2 } = await Promise.resolve().then(() => (init_langchain(), langchain_exports));
    integrations.langchain = LangChainIntegration2;
  } catch (_) {
  }
  try {
    await import("langgraph");
    const { LangGraphIntegration: LangGraphIntegration2 } = await Promise.resolve().then(() => (init_langgraph(), langgraph_exports));
    integrations.langgraph = LangGraphIntegration2;
  } catch (_) {
  }
  return integrations;
}
var init_utils = __esm({
  "src/observability/integrations/utils.ts"() {
    "use strict";
  }
});

// src/observability/Tracer.ts
var import_async_hooks, import_crypto2, import_timers, logger3, als, Tracer, tracer;
var init_Tracer = __esm({
  "src/observability/Tracer.ts"() {
    "use strict";
    import_async_hooks = require("async_hooks");
    import_crypto2 = require("crypto");
    init_Span();
    init_writer();
    import_timers = require("timers");
    init_utils();
    init_logger();
    if (process.env.ZEROEVAL_DEBUG?.toLowerCase() === "true") {
      Logger.setDebugMode(true);
    }
    logger3 = getLogger("zeroeval.tracer");
    als = new import_async_hooks.AsyncLocalStorage();
    Tracer = class {
      constructor() {
        this._writer = new BackendSpanWriter();
        this._buffer = [];
        this._flushIntervalMs = 1e4;
        // default 10 s
        this._maxSpans = 100;
        this._lastFlush = Date.now();
        this._activeTraceCounts = {};
        this._traceBuckets = {};
        this._integrations = {};
        this._shuttingDown = false;
        logger3.debug("Initializing tracer...");
        logger3.debug(
          `Tracer config: flush_interval=${this._flushIntervalMs}ms, max_spans=${this._maxSpans}`
        );
        (0, import_timers.setInterval)(() => {
          if (Date.now() - this._lastFlush >= this._flushIntervalMs) {
            void this.flush().catch((error) => {
              logger3.error("[ZeroEval] Periodic flush failed:", error);
            });
          }
        }, 1e3).unref();
        void this._setupAvailableIntegrations();
        process.on("beforeExit", () => this.shutdown());
        process.on("SIGINT", () => {
          this.shutdown();
          process.exit();
        });
        process.on("SIGTERM", () => {
          this.shutdown();
          process.exit();
        });
      }
      /* CONFIG ----------------------------------------------------------------*/
      configure(opts = {}) {
        if (opts.flushInterval !== void 0) {
          this._flushIntervalMs = opts.flushInterval * 1e3;
          logger3.info(
            `Tracer flush_interval configured to ${opts.flushInterval}s.`
          );
        }
        if (opts.maxSpans !== void 0) {
          this._maxSpans = opts.maxSpans;
          logger3.info(`Tracer max_spans configured to ${opts.maxSpans}.`);
        }
        logger3.debug(`Tracer configuration updated:`, opts);
      }
      /* ACTIVE SPAN -----------------------------------------------------------*/
      currentSpan() {
        const stack = als.getStore();
        return stack && stack[stack.length - 1];
      }
      /* TRACING ---------------------------------------------------------------*/
      startSpan(name, opts = {}) {
        logger3.debug(`Starting span: ${name}`);
        const parent = this.currentSpan();
        const span = new Span(name, parent?.traceId);
        if (parent) {
          span.parentId = parent.spanId;
          span.sessionId = parent.sessionId;
          span.sessionName = parent.sessionName;
          span.tags = { ...parent.tags, ...opts.tags };
          logger3.debug(`Span ${name} inherits from parent ${parent.name}`);
        } else {
          span.sessionId = opts.sessionId ?? (0, import_crypto2.randomUUID)();
          span.sessionName = opts.sessionName;
          span.tags = { ...opts.tags };
          logger3.debug(
            `Span ${name} is a root span with session ${span.sessionId}`
          );
        }
        Object.assign(span.attributes, opts.attributes);
        const parentStack = als.getStore() ?? [];
        als.enterWith([...parentStack, span]);
        this._activeTraceCounts[span.traceId] = (this._activeTraceCounts[span.traceId] || 0) + 1;
        return span;
      }
      endSpan(span) {
        var _a, _b;
        if (!span.endTime)
          span.end();
        logger3.debug(`Ending span: ${span.name} (duration: ${span.durationMs}ms)`);
        const stack = als.getStore();
        if (stack && stack[stack.length - 1] === span) {
          stack.pop();
        }
        const traceBucket = (_a = this._traceBuckets)[_b = span.traceId] || (_a[_b] = []);
        traceBucket.push(span);
        this._activeTraceCounts[span.traceId] -= 1;
        if (this._activeTraceCounts[span.traceId] === 0) {
          delete this._activeTraceCounts[span.traceId];
          const ordered = traceBucket.sort((a) => a.parentId ? 1 : -1);
          delete this._traceBuckets[span.traceId];
          this._buffer.push(...ordered);
          logger3.debug(
            `Trace ${span.traceId} complete with ${ordered.length} spans`
          );
        }
        if (this._buffer.length >= this._maxSpans) {
          logger3.debug(
            `Buffer full (${this._buffer.length} spans), triggering flush`
          );
          void this.flush().catch((error) => {
            logger3.error("[ZeroEval] Buffer full flush failed:", error);
          });
        }
      }
      /* TAG HELPERS -----------------------------------------------------------*/
      addTraceTags(traceId, tags) {
        logger3.debug(`Adding trace tags to ${traceId}:`, tags);
        for (const span of this._traceBuckets[traceId] ?? [])
          Object.assign(span.tags, tags);
        this._buffer.filter((s) => s.traceId === traceId).forEach((s) => Object.assign(s.tags, tags));
      }
      addSessionTags(sessionId, tags) {
        logger3.debug(`Adding session tags to ${sessionId}:`, tags);
        const all = [...Object.values(this._traceBuckets).flat(), ...this._buffer];
        all.filter((s) => s.sessionId === sessionId).forEach((s) => Object.assign(s.tags, tags));
      }
      isActiveTrace(traceId) {
        return traceId in this._activeTraceCounts || traceId in this._traceBuckets;
      }
      /* FLUSH -----------------------------------------------------------------*/
      async flush() {
        if (this._buffer.length === 0)
          return;
        const spanCount = this._buffer.length;
        logger3.info(`[ZeroEval] Flushing ${spanCount} spans to backend...`);
        this._lastFlush = Date.now();
        const spansToFlush = this._buffer.splice(0);
        try {
          const startTime = Date.now();
          await this._writer.write(spansToFlush);
          const duration = Date.now() - startTime;
          logger3.info(
            `[ZeroEval] Successfully flushed ${spanCount} spans in ${duration}ms`
          );
        } catch (error) {
          logger3.error(
            `[ZeroEval] Failed to flush ${spanCount} spans:`,
            error instanceof Error ? error.message : error
          );
          this._buffer.unshift(...spansToFlush);
          throw error;
        }
      }
      async _setupAvailableIntegrations() {
        logger3.info("Checking for available integrations...");
        const available = await discoverIntegrations();
        for (const [key, Ctor] of Object.entries(available)) {
          try {
            const inst = new Ctor();
            if (Ctor.isAvailable?.() !== false) {
              logger3.info(`Setting up integration: ${key}`);
              inst.setup();
              this._integrations[key] = inst;
              logger3.info(`\u2705 Successfully set up integration: ${key}`);
            }
          } catch (err) {
            logger3.error(`\u274C Failed to setup integration ${key}:`, err);
          }
        }
        if (Object.keys(this._integrations).length > 0) {
          logger3.info(
            `Active integrations: ${Object.keys(this._integrations).join(", ")}`
          );
        } else {
          logger3.info("No active integrations found.");
        }
      }
      /** Flush remaining spans and teardown integrations */
      shutdown() {
        if (this._shuttingDown)
          return;
        this._shuttingDown = true;
        logger3.info("Shutting down tracer...");
        void this.flush().catch((error) => {
          logger3.error("[ZeroEval] Shutdown flush failed:", error);
        });
        for (const inst of Object.values(this._integrations)) {
          try {
            inst.teardown();
          } catch (error) {
            logger3.error("[ZeroEval] Integration teardown failed:", error);
          }
        }
      }
    };
    tracer = new Tracer();
  }
});

// src/langchain.ts
var langchain_exports2 = {};
__export(langchain_exports2, {
  ZeroEvalCallbackHandler: () => ZeroEvalCallbackHandler,
  clearGlobalHandler: () => clearGlobalHandler,
  getGlobalHandler: () => getGlobalHandler,
  setGlobalCallbackHandler: () => setGlobalCallbackHandler
});
module.exports = __toCommonJS(langchain_exports2);

// src/observability/integrations/langchain/ZeroEvalCallbackHandler.ts
var import_base3 = require("@langchain/core/callbacks/base");
var import_messages = require("@langchain/core/messages");
init_Tracer();
init_logger();
var logger4 = getLogger("zeroeval.langchain");
var ObjectPool = class {
  constructor(factory, reset, maxSize = 100) {
    this.pool = [];
    this.factory = factory;
    this.reset = reset;
    this.maxSize = maxSize;
  }
  acquire() {
    return this.pool.pop() || this.factory();
  }
  release(obj) {
    if (this.pool.length < this.maxSize) {
      this.reset(obj);
      this.pool.push(obj);
    }
  }
};
var LazySerializer = class {
  constructor(value) {
    this.value = value;
  }
  toString() {
    if (!this.serialized) {
      this.serialized = typeof this.value === "string" ? this.value : JSON.stringify(this.value);
    }
    return this.serialized;
  }
};
var _ZeroEvalCallbackHandler = class _ZeroEvalCallbackHandler extends import_base3.BaseCallbackHandler {
  constructor(options) {
    super();
    this.name = "ZeroEvalCallbackHandler";
    this.spans = /* @__PURE__ */ new Map();
    this.spanStartTimes = /* @__PURE__ */ new Map();
    this.options = {
      debug: options?.debug ?? false,
      excludeMetadataProps: options?.excludeMetadataProps ?? /^(l[sc]_|langgraph_|__pregel_|checkpoint_ns)/,
      maxConcurrentSpans: options?.maxConcurrentSpans ?? 1e3,
      spanCleanupIntervalMs: options?.spanCleanupIntervalMs ?? 6e4
    };
    this.cachedRegex = this.options.excludeMetadataProps;
    this.metadataPool = new ObjectPool(
      () => ({}),
      (obj) => {
        Object.keys(obj).forEach((key) => delete obj[key]);
      }
    );
    this.startCleanupTimer();
  }
  startCleanupTimer() {
    this.cleanupTimer = setInterval(() => {
      this.cleanupOrphanedSpans();
    }, this.options.spanCleanupIntervalMs);
    this.cleanupTimer.unref();
  }
  cleanupOrphanedSpans() {
    const now = Date.now();
    const maxAge = 5 * 60 * 1e3;
    for (const [runId, startTime] of this.spanStartTimes) {
      if (now - startTime > maxAge) {
        const span = this.spans.get(runId);
        if (span) {
          span.setError({
            message: "Span orphaned - auto-cleaned after timeout"
          });
          tracer.endSpan(span);
        }
        this.spans.delete(runId);
        this.spanStartTimes.delete(runId);
      }
    }
  }
  startSpan({
    runId,
    parentRunId,
    name,
    type,
    input,
    tags,
    metadata
  }) {
    if (this.spans.has(runId)) {
      logger4.warn(`Span already exists for runId ${runId}`);
      return;
    }
    if (this.spans.size >= this.options.maxConcurrentSpans) {
      logger4.warn(
        `Max concurrent spans (${this.options.maxConcurrentSpans}) reached`
      );
      return;
    }
    if (!parentRunId) {
      this.rootRunId = runId;
    }
    const attributes = this.metadataPool.acquire();
    if (type)
      attributes.type = type;
    if (tags)
      attributes.tags = tags;
    if (type === "llm") {
      attributes.kind = "llm";
      if (attributes.provider === void 0) {
        attributes.provider = "openai";
      }
      if (attributes["service.name"] === void 0) {
        attributes["service.name"] = attributes.provider;
      }
    }
    if (metadata) {
      for (const [key, value] of Object.entries(metadata)) {
        if (!this.cachedRegex.test(key)) {
          attributes[key] = value;
        }
      }
    }
    if (this.options.debug) {
      attributes.runId = runId;
      attributes.parentRunId = parentRunId;
    }
    const spanTags = { integration: "langchain" };
    if (type)
      spanTags[`langchain.${type}`] = "true";
    const span = tracer.startSpan(name, {
      attributes,
      tags: spanTags
    });
    if (input !== void 0) {
      const lazyInput = new LazySerializer(input);
      span.setIO(lazyInput.toString(), void 0);
    }
    this.spans.set(runId, span);
    this.spanStartTimes.set(runId, Date.now());
    this.metadataPool.release(attributes);
  }
  endSpan({
    runId,
    output,
    error,
    tags,
    metadata
  }) {
    const span = this.spans.get(runId);
    if (!span) {
      logger4.warn(`No span exists for runId ${runId}`);
      return;
    }
    this.spans.delete(runId);
    this.spanStartTimes.delete(runId);
    if (runId === this.rootRunId) {
      this.rootRunId = void 0;
    }
    if (output !== void 0) {
      const lazyOutput = new LazySerializer(output);
      span.setIO(span.inputData, lazyOutput.toString());
    }
    if (error) {
      span.setError({ message: error });
    }
    if (tags || metadata) {
      const additionalAttrs = this.metadataPool.acquire();
      if (tags)
        additionalAttrs.tags = tags;
      if (metadata) {
        for (const [key, value] of Object.entries(metadata)) {
          if (!this.cachedRegex.test(key)) {
            additionalAttrs[key] = value;
          }
        }
      }
      Object.assign(span.attributes, additionalAttrs);
      this.metadataPool.release(additionalAttrs);
    }
    span.end();
    if (span.attributes.outputTokens && span.durationMs && span.durationMs > 0) {
      const outputTokens = span.attributes.outputTokens;
      span.attributes.throughput = Math.round(outputTokens / (span.durationMs / 1e3) * 100) / 100;
    }
    tracer.endSpan(span);
  }
  beginTracerSegment({
    runId,
    parentRunId,
    type,
    name,
    input,
    tags,
    metadata
  }) {
    this.startSpan({
      runId,
      parentRunId,
      name,
      type,
      input,
      tags,
      metadata
    });
  }
  finishTracerSegment({
    runId,
    output,
    error,
    tags,
    metadata
  }) {
    this.endSpan({ runId, output, error, tags, metadata });
  }
  deriveComponentName(serialized, fallback) {
    const lastId = serialized.id[serialized.id.length - 1];
    return lastId?.toString() ?? fallback;
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, runName) {
    const normalizedMetadata = metadata ? this.metadataPool.acquire() : {};
    if (metadata)
      Object.assign(normalizedMetadata, metadata);
    const invocationParams = extraParams?.invocation_params || {};
    const callParams = this.normalizeCallParamsOptimized(
      llm,
      invocationParams,
      metadata
    );
    Object.assign(normalizedMetadata, callParams);
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "llm",
      name: runName ?? this.deriveComponentName(llm, "LLM"),
      input: prompts,
      tags,
      metadata: normalizedMetadata
    });
    if (metadata)
      this.metadataPool.release(normalizedMetadata);
  }
  async handleLLMError(err, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, error: err.message, tags });
    }
  }
  async handleLLMEnd(output, runId, parentRunId, tags) {
    const span = this.spans.get(runId);
    if (!span)
      return;
    const { llmOutput, generations, ...metadata } = output;
    const tokenUsage = llmOutput?.tokenUsage || llmOutput?.estimatedTokens || {};
    if (tokenUsage.totalTokens || tokenUsage.promptTokens || tokenUsage.completionTokens) {
      if (tokenUsage.promptTokens) {
        span.attributes.inputTokens = tokenUsage.promptTokens;
      }
      if (tokenUsage.completionTokens) {
        span.attributes.outputTokens = tokenUsage.completionTokens;
      }
      if (!span.attributes.metrics) {
        span.attributes.metrics = {};
      }
      const metrics = span.attributes.metrics;
      if (tokenUsage.totalTokens)
        metrics.tokens = tokenUsage.totalTokens;
      if (tokenUsage.promptTokens)
        metrics.prompt_tokens = tokenUsage.promptTokens;
      if (tokenUsage.completionTokens)
        metrics.completion_tokens = tokenUsage.completionTokens;
    }
    this.finishTracerSegment({
      runId,
      output: this.flattenGenerationsOptimized(generations),
      tags,
      metadata
    });
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, runName) {
    const normalizedMetadata = this.metadataPool.acquire();
    if (metadata)
      Object.assign(normalizedMetadata, metadata);
    const invocationParams = extraParams?.invocation_params || {};
    const callParams = this.normalizeCallParamsOptimized(
      llm,
      invocationParams,
      metadata
    );
    Object.assign(normalizedMetadata, callParams);
    if (invocationParams.tools) {
      normalizedMetadata.tools = invocationParams.tools;
    }
    const flattenedMessages = this.flattenMessagesInputOptimized(messages);
    normalizedMetadata.messages = flattenedMessages;
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "llm",
      name: runName ?? this.deriveComponentName(llm, "Chat Model"),
      input: this.flattenMessagesInputOptimized(messages),
      tags,
      metadata: normalizedMetadata
    });
    this.metadataPool.release(normalizedMetadata);
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, runName) {
    if (tags?.includes("langsmith:hidden")) {
      return;
    }
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "chain",
      name: runName ?? this.deriveComponentName(chain, "Chain"),
      input: this.normalizeChainInputsOptimized(inputs),
      tags,
      metadata: {
        ...metadata,
        ...this.normalizeCallParamsOptimized(chain, {}, metadata)
      }
    });
  }
  async handleChainError(err, runId, parentRunId, tags, kwargs) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, error: err.toString(), tags });
    }
  }
  async handleChainEnd(outputs, runId, parentRunId, tags, kwargs) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({
        runId,
        tags,
        output: this.normalizeChainOutputsOptimized(outputs)
      });
    }
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, runName) {
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "tool",
      name: runName ?? this.deriveComponentName(tool, "Tool"),
      input: this.parseMaybeJsonOptimized(input),
      tags,
      metadata: {
        ...metadata,
        ...this.normalizeCallParamsOptimized(tool, {}, metadata)
      }
    });
  }
  async handleToolError(err, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, error: err.message, tags });
    }
  }
  async handleToolEnd(output, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({
        runId,
        output: this.normalizeToolOutputOptimized(output),
        tags
      });
    }
  }
  async handleAgentAction(action, runId, parentRunId, tags) {
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "agent",
      name: action.tool,
      input: action,
      tags
    });
  }
  async handleAgentEnd(action, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, output: action, tags });
    }
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    this.beginTracerSegment({
      runId,
      parentRunId,
      type: "retriever",
      name: name ?? this.deriveComponentName(retriever, "Retriever"),
      input: query,
      tags,
      metadata: {
        ...metadata,
        ...this.normalizeCallParamsOptimized(retriever, {}, metadata)
      }
    });
  }
  async handleRetrieverEnd(documents, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, output: documents, tags });
    }
  }
  async handleRetrieverError(err, runId, parentRunId, tags) {
    if (this.spans.has(runId)) {
      this.finishTracerSegment({ runId, error: err.message, tags });
    }
  }
  // Optimized helper functions
  normalizeCallParamsOptimized(llm, invocationParams, metadata) {
    const args = this.metadataPool.acquire();
    const model = _ZeroEvalCallbackHandler.chooseFirst(
      invocationParams?.model,
      metadata?.ls_model_name,
      llm.name
    );
    if (model !== void 0)
      args.model = model;
    const temperature = _ZeroEvalCallbackHandler.chooseFirst(
      invocationParams?.temperature,
      metadata?.ls_temperature
    );
    if (temperature !== void 0)
      args.temperature = temperature;
    const params = [
      ["top_p", invocationParams?.top_p ?? invocationParams?.topP],
      ["top_k", invocationParams?.top_k ?? invocationParams?.topK],
      [
        "max_tokens",
        invocationParams?.max_tokens ?? invocationParams?.maxOutputTokens
      ],
      ["frequency_penalty", invocationParams?.frequency_penalty],
      ["presence_penalty", invocationParams?.presence_penalty],
      ["response_format", invocationParams?.response_format],
      ["tool_choice", invocationParams?.tool_choice],
      ["function_call", invocationParams?.function_call],
      ["n", invocationParams?.n],
      ["stop", invocationParams?.stop ?? invocationParams?.stop_sequence]
    ];
    for (const [key, value] of params) {
      if (value !== void 0 && value !== null) {
        args[key] = value;
      }
    }
    const result = Object.keys(args).length ? { ...args } : invocationParams;
    this.metadataPool.release(args);
    return result;
  }
  flattenGenerationsOptimized(generations) {
    const result = [];
    for (const batch of generations) {
      if (Array.isArray(batch)) {
        for (const gen of batch) {
          const parsed = this.parseGenOptimized(gen);
          if (parsed !== void 0)
            result.push(parsed);
        }
      } else {
        const parsed = this.parseGenOptimized(batch);
        if (parsed !== void 0)
          result.push(parsed);
      }
    }
    return result;
  }
  parseGenOptimized(generation) {
    if ("message" in generation) {
      return this.extractMessageContentOptimized(generation.message);
    }
    return generation.text;
  }
  flattenMessagesInputOptimized(messages) {
    const result = [];
    for (const batch of messages) {
      for (const message of batch) {
        result.push(this.extractMessageContentOptimized(message));
      }
    }
    return result;
  }
  extractMessageContentOptimized(message) {
    const result = this.metadataPool.acquire();
    result.content = message.content;
    const messageType = message._getType();
    let role = message.name ?? messageType;
    if (messageType === "human")
      role = "user";
    else if (messageType === "ai")
      role = "assistant";
    else if (messageType === "system")
      role = "system";
    result.role = role;
    const anyMessage = message;
    if (anyMessage.tool_calls)
      result.tool_calls = anyMessage.tool_calls;
    if (anyMessage.status)
      result.status = anyMessage.status;
    if (anyMessage.artifact)
      result.artifact = anyMessage.artifact;
    const copy = { ...result };
    this.metadataPool.release(result);
    return copy;
  }
  parseMaybeJsonOptimized(input) {
    try {
      return JSON.parse(input);
    } catch {
      return input;
    }
  }
  normalizeToolOutputOptimized(output) {
    return output instanceof import_messages.ToolMessage ? this.extractMessageContentOptimized(output) : output;
  }
  normalizeChainOutputsOptimized(output) {
    const parsed = (Array.isArray(output) ? output : [output]).map(
      (item) => this.parseChainElementOptimized(item)
    );
    return parsed.length === 1 ? parsed[0] : parsed;
  }
  normalizeChainInputsOptimized(inputs) {
    const parsed = (Array.isArray(inputs) ? inputs : [inputs]).map(
      (item) => this.parseChainElementOptimized(item)
    );
    return parsed.length === 1 ? parsed[0] : parsed;
  }
  parseChainElementOptimized(output) {
    if (typeof output === "string") {
      return output;
    }
    if (!output) {
      return output;
    }
    if (output.content) {
      return output.content;
    }
    if (output.messages) {
      return output.messages.map(
        (msg) => this.parseChainElementOptimized(msg)
      );
    }
    if (output.value) {
      return output.value;
    }
    if (output.kwargs) {
      return this.parseChainElementOptimized(output.kwargs);
    }
    if (typeof output === "object" && output) {
      const result = this.metadataPool.acquire();
      for (const [key, value] of Object.entries(output)) {
        result[key] = this.parseChainElementOptimized(value);
      }
      const copy = { ...result };
      this.metadataPool.release(result);
      return copy;
    }
    return output;
  }
  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    for (const span of this.spans.values()) {
      span.setError({ message: "Handler destroyed with active span" });
      tracer.endSpan(span);
    }
    this.spans.clear();
    this.spanStartTimes.clear();
  }
};
_ZeroEvalCallbackHandler.chooseFirst = (...values) => {
  for (const value of values) {
    if (value !== void 0 && value !== null)
      return value;
  }
  return void 0;
};
var ZeroEvalCallbackHandler = _ZeroEvalCallbackHandler;

// src/observability/integrations/langchain/setGlobalCallbackHandler.ts
var globalHandler;
var setGlobalCallbackHandler = (handler) => {
  globalHandler = handler;
};
var getGlobalHandler = () => {
  return globalHandler;
};
var clearGlobalHandler = () => {
  globalHandler = void 0;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ZeroEvalCallbackHandler,
  clearGlobalHandler,
  getGlobalHandler,
  setGlobalCallbackHandler
});
