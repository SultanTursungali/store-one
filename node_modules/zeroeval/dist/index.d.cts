import { OpenAI } from 'openai';

interface InitOptions {
    apiKey?: string;
    apiUrl?: string;
    workspaceName?: string;
    flushInterval?: number;
    maxSpans?: number;
    collectCodeDetails?: boolean;
    integrations?: Record<string, boolean>;
    debug?: boolean;
}
/**
 * Check if the SDK has been initialized
 */
declare function isInitialized(): boolean;
/**
 * Validate the initialization of the ZeroEval SDK
 */
declare function validateInit(): boolean;
/**
 * Initialise the SDK. Mirrors `ze.init()` from the Python SDK.
 * Stores credentials in process.env for simplicity; callers may also
 * set env vars before requiring the SDK.
 */
declare function init(opts?: InitOptions): void;

interface SpanOptions {
    name: string;
    sessionId?: string;
    sessionName?: string;
    tags?: Record<string, string>;
    attributes?: Record<string, unknown>;
    inputData?: unknown;
    outputData?: unknown;
}
declare function span(opts: SpanOptions): MethodDecorator & ((target: any, ...args: any[]) => any);
declare function withSpan<T>(opts: SpanOptions, fn: () => Promise<T> | T): Promise<T> | T;

type SignalType = 'boolean' | 'numerical';
interface Signal {
    value: string | boolean | number;
    type: SignalType;
}
interface SignalCreate {
    entity_type: 'session' | 'trace' | 'span' | 'completion';
    entity_id: string;
    name: string;
    value: string | boolean | number;
    signal_type?: SignalType;
}

interface ErrorInfo {
    code?: string;
    message?: string;
    stack?: string;
}
declare class Span {
    readonly spanId: string;
    readonly traceId: string;
    parentId?: string;
    readonly name: string;
    readonly startTime: number;
    endTime?: number;
    sessionId?: string;
    sessionName?: string;
    attributes: Record<string, unknown>;
    tags: Record<string, string>;
    traceTags: Record<string, string>;
    sessionTags: Record<string, string>;
    signals: Record<string, Signal>;
    inputData?: string;
    outputData?: string;
    error?: ErrorInfo;
    status: 'ok' | 'error';
    constructor(name: string, traceId?: string);
    end(): void;
    get durationMs(): number | undefined;
    setError(info: ErrorInfo): void;
    setIO(input?: unknown, output?: unknown): void;
    addSignal(name: string, value: string | boolean | number, type?: 'boolean' | 'numerical'): void;
    toJSON(): Record<string, unknown>;
}

interface ConfigureOptions {
    flushInterval?: number;
    maxSpans?: number;
    collectCodeDetails?: boolean;
    integrations?: Record<string, boolean>;
}
declare class Tracer {
    private _writer;
    private _buffer;
    private _flushIntervalMs;
    private _maxSpans;
    private _lastFlush;
    private _activeTraceCounts;
    private _traceBuckets;
    private _integrations;
    private _shuttingDown;
    constructor();
    configure(opts?: ConfigureOptions): void;
    currentSpan(): Span | undefined;
    startSpan(name: string, opts?: {
        attributes?: Record<string, unknown>;
        sessionId?: string;
        sessionName?: string;
        tags?: Record<string, string>;
    }): Span;
    endSpan(span: Span): void;
    addTraceTags(traceId: string, tags: Record<string, string>): void;
    addSessionTags(sessionId: string, tags: Record<string, string>): void;
    isActiveTrace(traceId: string): boolean;
    flush(): Promise<void>;
    private _setupAvailableIntegrations;
    /** Flush remaining spans and teardown integrations */
    shutdown(): void;
}
declare const tracer: Tracer;

/** Return the current active Span (or undefined). */
declare function getCurrentSpan(): Span | undefined;
/** Return the current trace ID (or undefined). */
declare function getCurrentTrace(): string | undefined;
/** Return the current session ID (or undefined). */
declare function getCurrentSession(): string | undefined;
/** Attach tags to a span / trace / session following Python SDK semantics. */
declare function setTag(target: Span | string | undefined, tags: Record<string, string>): void;

type WrappedClient<T> = T & {
    __zeroeval_wrapped?: boolean;
};
/**
 * Wraps a supported AI client to automatically trace all API calls.
 * Automatically detects the client type and applies the appropriate wrapper.
 *
 * If ze.init() hasn't been called yet and ZEROEVAL_API_KEY is set in the environment,
 * the SDK will be automatically initialized.
 *
 * @param client - The AI client instance to wrap (currently supports OpenAI and Vercel AI SDK)
 * @returns A wrapped client with automatic tracing
 *
 * @example
 * ```ts
 * import { OpenAI } from 'openai';
 * import * as ze from '@zeroeval/sdk';
 *
 * // Simplest usage - both SDKs use environment variables
 * const openai = ze.wrap(new OpenAI());
 *
 * // Use the client normally - all calls will be traced
 * const completion = await openai.chat.completions.create({
 *   model: 'gpt-4',
 *   messages: [{ role: 'user', content: 'Hello!' }]
 * });
 * ```
 *
 * @example
 * ```ts
 * import * as ai from 'ai';
 * import * as ze from '@zeroeval/sdk';
 *
 * // Wrap the Vercel AI SDK
 * const wrappedAI = ze.wrap(ai);
 *
 * // Use the wrapped functions - all calls will be traced
 * const { text } = await wrappedAI.generateText({
 *   model: openai('gpt-4'),
 *   prompt: 'Hello!'
 * });
 * ```
 */
declare function wrap<T extends object>(client: T): WrappedClient<T>;

type OpenAIClient = InstanceType<typeof OpenAI>;
type WrappedOpenAI<T extends OpenAIClient> = T & {
    __zeroeval_wrapped?: boolean;
};
/**
 * Wraps an OpenAI client instance to automatically trace all API calls.
 * This approach provides better TypeScript support and is more maintainable
 * than monkey patching.
 *
 * If ze.init() hasn't been called yet and ZEROEVAL_API_KEY is set in the environment,
 * the SDK will be automatically initialized.
 *
 * @param client - The OpenAI client instance to wrap
 * @returns A wrapped OpenAI client with automatic tracing
 *
 * @example
 * ```ts
 * import { OpenAI } from 'openai';
 * import { wrapOpenAI } from '@zeroeval/sdk';
 *
 * // No need to call ze.init() if ZEROEVAL_API_KEY is set
 * const client = wrapOpenAI(new OpenAI({ apiKey: 'your-key' }));
 *
 * // Use the client normally - all calls will be traced
 * const completion = await client.chat.completions.create({
 *   model: 'gpt-4',
 *   messages: [{ role: 'user', content: 'Hello!' }]
 * });
 * ```
 */
declare function wrapOpenAI<T extends OpenAIClient>(client: T): WrappedOpenAI<T>;

type WrappedVercelAI<T> = T & {
    __zeroeval_wrapped?: boolean;
};
/**
 * Wraps Vercel AI SDK exports to automatically trace all API calls.
 * This wrapper supports the main AI SDK functions like generateText, streamText,
 * generateObject, and embed.
 *
 * @param aiModule - The Vercel AI SDK module exports
 * @returns A wrapped module with automatic tracing
 *
 * @example
 * ```ts
 * import * as ai from 'ai';
 * import * as ze from '@zeroeval/sdk';
 *
 * // Wrap the entire AI SDK module
 * const wrappedAI = ze.wrapVercelAI(ai);
 *
 * // Use the wrapped functions - all calls will be traced
 * const { text } = await wrappedAI.generateText({
 *   model: openai('gpt-4'),
 *   prompt: 'Hello!'
 * });
 * ```
 */
declare function wrapVercelAI<T extends Record<string, any>>(aiModule: T): WrappedVercelAI<T>;

declare abstract class Integration {
    static readonly PATCHED: unique symbol;
    protected originals: Map<object, Map<string, unknown>>;
    protected patchMethod<T extends object, K extends keyof T>(obj: T, key: K, build: (orig: T[K]) => T[K]): void;
    teardown(): void;
    abstract setup(): Promise<void> | void;
}

declare class LangChainIntegration extends Integration {
    static isAvailable(): boolean;
    setup(): Promise<void>;
}

/**
 * Send a signal to a specific entity
 * @param entityType - Type of entity: 'session' | 'trace' | 'span' | 'completion'
 * @param entityId - UUID of the entity
 * @param name - Name of the signal
 * @param value - Signal value (string, boolean, or number)
 * @param signalType - Optional signal type, will be auto-detected if not provided
 */
declare function sendSignal(entityType: 'session' | 'trace' | 'span' | 'completion', entityId: string, name: string, value: string | boolean | number, signalType?: 'boolean' | 'numerical'): Promise<void>;
/**
 * Send multiple signals in bulk
 * @param signals - Array of signal creates
 */
declare function sendBulkSignals(signals: SignalCreate[]): Promise<void>;
/**
 * Send a signal to the current trace
 * @param name - Name of the signal
 * @param value - Signal value (string, boolean, or number)
 * @param signalType - Optional signal type, will be auto-detected if not provided
 */
declare function sendTraceSignal(name: string, value: string | boolean | number, signalType?: 'boolean' | 'numerical'): void;
/**
 * Send a signal to the current session
 * @param name - Name of the signal
 * @param value - Signal value (string, boolean, or number)
 * @param signalType - Optional signal type, will be auto-detected if not provided
 */
declare function sendSessionSignal(name: string, value: string | boolean | number, signalType?: 'boolean' | 'numerical'): void;
/**
 * Send a signal to the current span
 * @param name - Name of the signal
 * @param value - Signal value (string, boolean, or number)
 * @param signalType - Optional signal type, will be auto-detected if not provided
 */
declare function sendSpanSignal(name: string, value: string | boolean | number, signalType?: 'boolean' | 'numerical'): void;
/**
 * Get all signals for a specific entity
 * @param entityType - Type of entity
 * @param entityId - UUID of the entity
 * @returns Array of signals
 */
declare function getEntitySignals(entityType: 'session' | 'trace' | 'span' | 'completion', entityId: string): Promise<Signal[]>;

export { LangChainIntegration, Signal, SignalCreate, Span, getCurrentSession, getCurrentSpan, getCurrentTrace, getEntitySignals, init, isInitialized, sendBulkSignals, sendSessionSignal, sendSignal, sendSpanSignal, sendTraceSignal, setTag, span, tracer, validateInit, withSpan, wrap, wrapOpenAI, wrapVercelAI };
