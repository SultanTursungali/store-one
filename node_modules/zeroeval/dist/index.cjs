"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/observability/Span.ts
var import_crypto, Span;
var init_Span = __esm({
  "src/observability/Span.ts"() {
    "use strict";
    import_crypto = require("crypto");
    Span = class {
      constructor(name, traceId) {
        this.spanId = (0, import_crypto.randomUUID)();
        this.startTime = Date.now();
        this.attributes = {};
        this.tags = {};
        this.traceTags = {};
        this.sessionTags = {};
        this.signals = {};
        this.status = "ok";
        this.name = name;
        this.traceId = traceId ?? (0, import_crypto.randomUUID)();
      }
      end() {
        this.endTime = Date.now();
      }
      get durationMs() {
        return this.endTime ? this.endTime - this.startTime : void 0;
      }
      setError(info) {
        this.error = info;
        this.status = "error";
      }
      setIO(input, output) {
        if (input !== void 0) {
          this.inputData = typeof input === "string" ? input : JSON.stringify(input);
        }
        if (output !== void 0) {
          this.outputData = typeof output === "string" ? output : JSON.stringify(output);
        }
      }
      addSignal(name, value, type) {
        let signalType = type;
        if (!signalType) {
          if (typeof value === "boolean") {
            signalType = "boolean";
          } else if (typeof value === "number") {
            signalType = "numerical";
          } else {
            const strVal = String(value).toLowerCase();
            if (strVal === "true" || strVal === "false") {
              signalType = "boolean";
            } else if (!isNaN(Number(value))) {
              signalType = "numerical";
            } else {
              signalType = "boolean";
            }
          }
        }
        this.signals[name] = {
          value,
          type: signalType
        };
      }
      toJSON() {
        return {
          span_id: this.spanId,
          trace_id: this.traceId,
          parent_id: this.parentId,
          name: this.name,
          start_time: new Date(this.startTime).toISOString(),
          end_time: this.endTime ? new Date(this.endTime).toISOString() : void 0,
          duration_ms: this.durationMs,
          session_id: this.sessionId,
          session_name: this.sessionName,
          attributes: this.attributes,
          tags: this.tags,
          trace_tags: this.traceTags,
          session_tags: this.sessionTags,
          signals: this.signals,
          input_data: this.inputData,
          output_data: this.outputData,
          error_code: this.error?.code,
          error_message: this.error?.message,
          error_stack: this.error?.stack,
          status: this.status
        };
      }
    };
  }
});

// src/observability/logger.ts
function getLogger(name) {
  return new Logger(name);
}
var colors, _Logger, Logger;
var init_logger = __esm({
  "src/observability/logger.ts"() {
    "use strict";
    colors = {
      grey: "\x1B[38;5;244m",
      blue: "\x1B[34;1m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      red: "\x1B[31m",
      boldRed: "\x1B[31;1m",
      reset: "\x1B[0m"
    };
    _Logger = class _Logger {
      constructor(name) {
        this.name = name;
      }
      static setDebugMode(enabled) {
        _Logger.isDebugMode = enabled;
        _Logger.globalLevel = enabled ? 0 /* DEBUG */ : 2 /* WARN */;
        _Logger.bufferEarlyLogs = false;
        if (enabled && _Logger.earlyLogs.length > 0) {
          console.log("[zeroeval] Replaying buffered debug logs...");
          for (const log of _Logger.earlyLogs) {
            if (_Logger.globalLevel <= log.level) {
              const fn = log.level <= 1 /* INFO */ ? console.log : console.error;
              fn(
                log.logger.formatMessage(
                  log.levelName,
                  log.levelColor,
                  log.message
                ),
                ...log.args
              );
            }
          }
          _Logger.earlyLogs = [];
        }
      }
      static isDebugEnabled() {
        return _Logger.isDebugMode;
      }
      formatTimestamp() {
        const now = /* @__PURE__ */ new Date();
        const hours = now.getHours().toString().padStart(2, "0");
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const seconds = now.getSeconds().toString().padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }
      formatMessage(level, levelColor, message) {
        if (!_Logger.isDebugMode) {
          return `[${this.name}] [${level}] ${message}`;
        }
        const timestamp = this.formatTimestamp();
        return `${colors.grey}[${timestamp}]${colors.reset} ${colors.blue}[${this.name}]${colors.reset} ${levelColor}[${level}]${colors.reset} ${message}`;
      }
      debug(message, ...args) {
        if (_Logger.bufferEarlyLogs && 0 /* DEBUG */ >= _Logger.globalLevel) {
          _Logger.earlyLogs.push({
            logger: this,
            level: 0 /* DEBUG */,
            levelName: "DEBUG",
            levelColor: colors.blue,
            message,
            args
          });
          return;
        }
        if (_Logger.globalLevel <= 0 /* DEBUG */) {
          console.log(this.formatMessage("DEBUG", colors.blue, message), ...args);
        }
      }
      info(message, ...args) {
        if (_Logger.bufferEarlyLogs && 1 /* INFO */ >= _Logger.globalLevel) {
          _Logger.earlyLogs.push({
            logger: this,
            level: 1 /* INFO */,
            levelName: "INFO",
            levelColor: colors.green,
            message,
            args
          });
          return;
        }
        if (_Logger.globalLevel <= 1 /* INFO */) {
          console.log(this.formatMessage("INFO", colors.green, message), ...args);
        }
      }
      warn(message, ...args) {
        if (_Logger.globalLevel <= 2 /* WARN */) {
          console.warn(this.formatMessage("WARN", colors.yellow, message), ...args);
        }
      }
      error(message, ...args) {
        if (_Logger.globalLevel <= 3 /* ERROR */) {
          console.error(this.formatMessage("ERROR", colors.red, message), ...args);
        }
      }
      critical(message, ...args) {
        if (_Logger.globalLevel <= 4 /* CRITICAL */) {
          console.error(
            this.formatMessage("CRITICAL", colors.boldRed, message),
            ...args
          );
        }
      }
      /**
       * Mask sensitive data like API keys for logging
       */
      static maskApiKey(apiKey) {
        if (!apiKey)
          return "Not set";
        if (apiKey.length <= 8)
          return "***";
        return `${apiKey.substring(0, 8)}...`;
      }
    };
    _Logger.globalLevel = 2 /* WARN */;
    _Logger.isDebugMode = false;
    _Logger.earlyLogs = [];
    _Logger.bufferEarlyLogs = true;
    Logger = _Logger;
  }
});

// src/observability/signalWriter.ts
var logger, SignalWriter, signalWriter;
var init_signalWriter = __esm({
  "src/observability/signalWriter.ts"() {
    "use strict";
    init_logger();
    logger = getLogger("zeroeval.signalWriter");
    SignalWriter = class {
      getApiUrl() {
        return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
          /\/$/,
          ""
        );
      }
      getApiKey() {
        return process.env.ZEROEVAL_API_KEY;
      }
      /**
       * Send a single signal to the backend
       */
      async createSignal(signal) {
        const endpoint = `${this.getApiUrl()}/signals/`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        logger.debug(`[ZeroEval] Sending signal to ${endpoint}`);
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger.debug("[ZeroEval] Request body:", JSON.stringify(signal, null, 2));
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(signal)
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed creating signal: ${res.status} ${text}`
            );
            return {
              status: "error",
              message: `Failed to create signal: ${res.status} ${text}`
            };
          }
          logger.info(
            `[ZeroEval] Successfully created signal for ${signal.entity_type}:${signal.entity_id} - ${signal.name}`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error creating signal", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              signal,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return {
            status: "error",
            message: `Error creating signal: ${err instanceof Error ? err.message : String(err)}`
          };
        }
      }
      /**
       * Send multiple signals to the backend in bulk
       */
      async createBulkSignals(signals) {
        const endpoint = `${this.getApiUrl()}/signals/bulk`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        const bulkRequest = { signals };
        logger.debug(
          `[ZeroEval] Sending ${signals.length} bulk signals to ${endpoint}`
        );
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger.debug(
            "[ZeroEval] Request body:",
            JSON.stringify(bulkRequest, null, 2)
          );
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(bulkRequest)
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed creating bulk signals: ${res.status} ${text}`
            );
            return {
              status: "error",
              message: `Failed to create bulk signals: ${res.status} ${text}`
            };
          }
          logger.info(
            `[ZeroEval] Successfully created ${signals.length} bulk signals`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error creating bulk signals", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              signalCount: signals.length,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return {
            status: "error",
            message: `Error creating bulk signals: ${err instanceof Error ? err.message : String(err)}`
          };
        }
      }
      /**
       * Get all signals for a specific entity
       */
      async getEntitySignals(entityType, entityId) {
        const endpoint = `${this.getApiUrl()}/signals/entity/${entityType}/${entityId}`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        logger.debug(
          `[ZeroEval] Getting signals for ${entityType}:${entityId} from ${endpoint}`
        );
        if (Logger.isDebugEnabled()) {
          logger.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "GET",
            headers
          });
          const duration = Date.now() - startTime;
          logger.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger.error(
              `[ZeroEval] Failed getting entity signals: ${res.status} ${text}`
            );
            return null;
          }
          logger.info(
            `[ZeroEval] Successfully retrieved signals for ${entityType}:${entityId}`
          );
          return JSON.parse(text);
        } catch (err) {
          logger.error("[ZeroEval] Error getting entity signals", err);
          if (Logger.isDebugEnabled()) {
            logger.debug("[ZeroEval] Error details:", {
              endpoint,
              entityType,
              entityId,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
          return null;
        }
      }
    };
    signalWriter = new SignalWriter();
  }
});

// src/observability/pendingSignals.ts
var pendingSignals_exports = {};
__export(pendingSignals_exports, {
  addPendingSessionSignal: () => addPendingSessionSignal,
  addPendingTraceSignal: () => addPendingTraceSignal,
  popPendingSessionSignals: () => popPendingSessionSignals,
  popPendingTraceSignals: () => popPendingTraceSignals
});
function addPendingTraceSignal(traceId, name, signal) {
  const bucket = traceBuffer[traceId] || (traceBuffer[traceId] = {});
  bucket[name] = signal;
}
function popPendingTraceSignals(traceId) {
  const sigs = traceBuffer[traceId];
  if (sigs)
    delete traceBuffer[traceId];
  return sigs;
}
function addPendingSessionSignal(sessionId, name, signal) {
  const bucket = sessionBuffer[sessionId] || (sessionBuffer[sessionId] = {});
  bucket[name] = signal;
}
function popPendingSessionSignals(sessionId) {
  const sigs = sessionBuffer[sessionId];
  if (sigs)
    delete sessionBuffer[sessionId];
  return sigs;
}
var traceBuffer, sessionBuffer;
var init_pendingSignals = __esm({
  "src/observability/pendingSignals.ts"() {
    "use strict";
    traceBuffer = {};
    sessionBuffer = {};
  }
});

// src/observability/writer.ts
var logger2, BackendSpanWriter;
var init_writer = __esm({
  "src/observability/writer.ts"() {
    "use strict";
    init_signalWriter();
    init_logger();
    logger2 = getLogger("zeroeval.writer");
    BackendSpanWriter = class {
      getApiUrl() {
        return (process.env.ZEROEVAL_API_URL ?? "https://api.zeroeval.com").replace(
          /\/$/,
          ""
        );
      }
      getApiKey() {
        return process.env.ZEROEVAL_API_KEY;
      }
      async write(spans) {
        if (!spans.length)
          return;
        const endpoint = `${this.getApiUrl()}/spans`;
        const headers = {
          "Content-Type": "application/json"
        };
        const apiKey = this.getApiKey();
        if (apiKey)
          headers.Authorization = `Bearer ${apiKey}`;
        const spansWithSignals = [];
        const traceIds = /* @__PURE__ */ new Set();
        const sessionIds = /* @__PURE__ */ new Set();
        const payload = spans.map((s) => {
          const base = typeof s.toJSON === "function" ? s.toJSON() : s;
          if (base.signals && Object.keys(base.signals).length > 0) {
            spansWithSignals.push({ spanId: base.span_id, signals: base.signals });
          }
          traceIds.add(base.trace_id);
          if (base.session_id)
            sessionIds.add(base.session_id);
          return {
            id: base.span_id,
            session_id: base.session_id,
            session_name: base.session_name,
            trace_id: base.trace_id,
            parent_span_id: base.parent_id,
            name: base.name,
            started_at: base.start_time,
            ended_at: base.end_time,
            duration_ms: base.duration_ms,
            attributes: base.attributes,
            status: base.status,
            input_data: base.input_data,
            output_data: base.output_data,
            code: base.code ?? base.attributes?.code,
            code_filepath: base.code_filepath ?? base.attributes?.code_filepath,
            code_lineno: base.code_lineno ?? base.attributes?.code_lineno,
            error_code: base.error_code,
            error_message: base.error_message,
            error_stack: String(base.error_stack ?? ""),
            tags: base.tags,
            trace_tags: base.trace_tags,
            session_tags: base.session_tags
          };
        });
        logger2.debug(`[ZeroEval] Sending ${payload.length} spans to ${endpoint}`);
        if (Logger.isDebugEnabled()) {
          logger2.debug("[ZeroEval] Request headers:", {
            ...headers,
            Authorization: headers.Authorization ? `Bearer ${Logger.maskApiKey(apiKey)}` : void 0
          });
          logger2.debug(
            "[ZeroEval] Request body:",
            JSON.stringify(payload, null, 2)
          );
        }
        try {
          const startTime = Date.now();
          const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          });
          const duration = Date.now() - startTime;
          logger2.debug(
            `[ZeroEval] Response received in ${duration}ms - Status: ${res.status}`
          );
          const text = await res.text();
          if (Logger.isDebugEnabled()) {
            const responseHeaders = {};
            res.headers.forEach((value, key) => {
              responseHeaders[key] = value;
            });
            logger2.debug(`[ZeroEval] Response headers:`, responseHeaders);
            logger2.debug(`[ZeroEval] Response body:`, text);
          }
          if (!res.ok) {
            logger2.error(`[ZeroEval] Failed posting spans: ${res.status} ${text}`);
          } else {
            logger2.info(
              `[ZeroEval] Successfully posted ${payload.length} spans to ${endpoint}`
            );
            await this.sendSpanSignals(spansWithSignals);
            await this.flushTraceSessionSignals(
              Array.from(traceIds),
              Array.from(sessionIds)
            );
          }
        } catch (err) {
          logger2.error("[ZeroEval] Error posting spans", err);
          if (Logger.isDebugEnabled()) {
            logger2.debug("[ZeroEval] Error details:", {
              endpoint,
              spanCount: payload.length,
              error: err instanceof Error ? {
                name: err.name,
                message: err.message,
                stack: err.stack
              } : err
            });
          }
        }
      }
      async sendSpanSignals(spansWithSignals) {
        if (spansWithSignals.length === 0)
          return;
        const bulkSignals = [];
        for (const { spanId, signals } of spansWithSignals) {
          for (const [name, signal] of Object.entries(signals)) {
            bulkSignals.push({
              entity_type: "span",
              entity_id: spanId,
              name,
              value: signal.value,
              signal_type: signal.type
            });
          }
        }
        if (bulkSignals.length > 0) {
          try {
            await signalWriter.createBulkSignals(bulkSignals);
          } catch (err) {
            logger2.error("[ZeroEval] Error sending span signals", err);
          }
        }
      }
      async flushTraceSessionSignals(traceIds, sessionIds) {
        if (traceIds.length === 0 && sessionIds.length === 0)
          return;
        const { popPendingTraceSignals: popPendingTraceSignals2, popPendingSessionSignals: popPendingSessionSignals2 } = await Promise.resolve().then(() => (init_pendingSignals(), pendingSignals_exports));
        const bulk = [];
        for (const tid of traceIds) {
          const signals = popPendingTraceSignals2(tid);
          if (!signals)
            continue;
          for (const [name, sig] of Object.entries(signals)) {
            bulk.push({
              entity_type: "trace",
              entity_id: tid,
              name,
              value: sig.value,
              signal_type: sig.type
            });
          }
        }
        for (const sid of sessionIds) {
          const signals = popPendingSessionSignals2(sid);
          if (!signals)
            continue;
          for (const [name, sig] of Object.entries(signals)) {
            bulk.push({
              entity_type: "session",
              entity_id: sid,
              name,
              value: sig.value,
              signal_type: sig.type
            });
          }
        }
        if (bulk.length > 0) {
          try {
            await signalWriter.createBulkSignals(bulk);
          } catch (err) {
            logger2.error("[ZeroEval] Error posting trace/session signals", err);
          }
        }
      }
    };
  }
});

// src/observability/integrations/base.ts
var _Integration, Integration;
var init_base = __esm({
  "src/observability/integrations/base.ts"() {
    "use strict";
    _Integration = class _Integration {
      constructor() {
        this.originals = /* @__PURE__ */ new Map();
      }
      patchMethod(obj, key, build) {
        const orig = obj[key];
        if (typeof orig !== "function" || orig[_Integration.PATCHED])
          return;
        const wrapped = build(orig);
        wrapped[_Integration.PATCHED] = true;
        if (!this.originals.has(obj))
          this.originals.set(obj, /* @__PURE__ */ new Map());
        this.originals.get(obj).set(key, orig);
        obj[key] = wrapped;
      }
      teardown() {
        for (const [obj, map] of this.originals.entries()) {
          for (const [k, fn] of map) {
            obj[k] = fn;
          }
        }
        this.originals = /* @__PURE__ */ new Map();
      }
    };
    _Integration.PATCHED = Symbol("zePatched");
    Integration = _Integration;
  }
});

// src/observability/integrations/langchain.ts
var langchain_exports = {};
__export(langchain_exports, {
  LangChainIntegration: () => LangChainIntegration
});
var LangChainIntegration;
var init_langchain = __esm({
  "src/observability/integrations/langchain.ts"() {
    "use strict";
    init_base();
    init_Tracer();
    LangChainIntegration = class extends Integration {
      static isAvailable() {
        try {
          require.resolve("langchain");
          return true;
        } catch (_) {
          try {
            require.resolve("langchain-core");
            return true;
          } catch {
            return false;
          }
        }
      }
      async setup() {
        let mod;
        try {
          mod = await import("langchain");
        } catch {
          try {
            mod = await import("langchain-core");
          } catch {
            return;
          }
        }
        const Runnable = mod.Runnable ?? mod.RunnableBase ?? mod.RunnableSequence ?? void 0;
        if (!Runnable)
          return;
        const methods = [
          "invoke",
          "ainvoke",
          "stream",
          "astream",
          "batch",
          "abatch"
        ];
        for (const method of methods) {
          if (typeof Runnable.prototype[method] !== "function")
            continue;
          this.patchMethod(
            Runnable.prototype,
            method,
            (orig) => {
              const isAsync = method.toString().startsWith("a");
              const name = `langchain.${String(method)}`;
              if (isAsync) {
                return async function patched(...args) {
                  const className = this?.constructor?.name;
                  const attrs = {
                    class: className,
                    method: String(method)
                  };
                  if (typeof className === "string" && className.includes("ChatOpenAI")) {
                    attrs.kind = "llm";
                    attrs.provider = "openai";
                    attrs["service.name"] = "openai";
                  }
                  const span2 = tracer.startSpan(name, {
                    attributes: attrs,
                    tags: { integration: "langchain" }
                  });
                  try {
                    const res = await orig.apply(this, args);
                    span2.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                    tracer.endSpan(span2);
                    return res;
                  } catch (err) {
                    span2.setError({
                      code: err?.name,
                      message: err?.message,
                      stack: err?.stack
                    });
                    tracer.endSpan(span2);
                    throw err;
                  }
                };
              }
              return function patched(...args) {
                const className = this?.constructor?.name;
                const attrs = {
                  class: className,
                  method: String(method)
                };
                if (typeof className === "string" && className.includes("ChatOpenAI")) {
                  attrs.kind = "llm";
                  attrs.provider = "openai";
                  attrs["service.name"] = "openai";
                }
                const span2 = tracer.startSpan(name, {
                  attributes: attrs,
                  tags: { integration: "langchain" }
                });
                try {
                  const res = orig.apply(this, args);
                  if (res?.then) {
                    return res.then((r) => {
                      span2.setIO(JSON.stringify(args[0]), JSON.stringify(r));
                      tracer.endSpan(span2);
                      return r;
                    }).catch((err) => {
                      span2.setError({
                        code: err?.name,
                        message: err?.message,
                        stack: err?.stack
                      });
                      tracer.endSpan(span2);
                      throw err;
                    });
                  }
                  span2.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                  tracer.endSpan(span2);
                  return res;
                } catch (err) {
                  span2.setError({
                    code: err?.name,
                    message: err?.message,
                    stack: err?.stack
                  });
                  tracer.endSpan(span2);
                  throw err;
                }
              };
            }
          );
        }
      }
    };
  }
});

// src/observability/integrations/langgraph.ts
var langgraph_exports = {};
__export(langgraph_exports, {
  LangGraphIntegration: () => LangGraphIntegration
});
var LangGraphIntegration;
var init_langgraph = __esm({
  "src/observability/integrations/langgraph.ts"() {
    "use strict";
    init_base();
    init_Tracer();
    LangGraphIntegration = class extends Integration {
      static isAvailable() {
        try {
          require.resolve("langgraph");
          return true;
        } catch (_) {
          return false;
        }
      }
      async setup() {
        let mod;
        try {
          mod = await import("langgraph");
        } catch {
          return;
        }
        const Graph = mod.Graph ?? mod.StateGraph ?? void 0;
        if (!Graph)
          return;
        const patchInvoke = (obj) => {
          ["invoke", "ainvoke"].forEach((method) => {
            if (typeof obj.prototype[method] !== "function")
              return;
            this.patchMethod(obj.prototype, method, (orig) => {
              const isAsync = method.startsWith("a");
              const name = `langgraph.${method}`;
              if (isAsync) {
                return async function patched(...args) {
                  const span2 = tracer.startSpan(name, {
                    attributes: { class: this?.constructor?.name },
                    tags: { integration: "langgraph" }
                  });
                  try {
                    const res = await orig.apply(this, args);
                    span2.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                    tracer.endSpan(span2);
                    return res;
                  } catch (err) {
                    span2.setError({
                      code: err?.name,
                      message: err?.message,
                      stack: err?.stack
                    });
                    tracer.endSpan(span2);
                    throw err;
                  }
                };
              }
              return function patched(...args) {
                const span2 = tracer.startSpan(name, {
                  attributes: { class: this?.constructor?.name },
                  tags: { integration: "langgraph" }
                });
                try {
                  const res = orig.apply(this, args);
                  if (res?.then) {
                    return res.then((r) => {
                      span2.setIO(JSON.stringify(args[0]), JSON.stringify(r));
                      tracer.endSpan(span2);
                      return r;
                    }).catch((err) => {
                      span2.setError({
                        code: err?.name,
                        message: err?.message,
                        stack: err?.stack
                      });
                      tracer.endSpan(span2);
                      throw err;
                    });
                  }
                  span2.setIO(JSON.stringify(args[0]), JSON.stringify(res));
                  tracer.endSpan(span2);
                  return res;
                } catch (err) {
                  span2.setError({
                    code: err?.name,
                    message: err?.message,
                    stack: err?.stack
                  });
                  tracer.endSpan(span2);
                  throw err;
                }
              };
            });
          });
        };
        patchInvoke(Graph);
        if (Graph.prototype?.compile) {
          this.patchMethod(Graph.prototype, "compile", (orig) => {
            return function patched(...args) {
              const compiled = orig.apply(this, args);
              patchInvoke(compiled.constructor);
              return compiled;
            };
          });
        }
      }
    };
  }
});

// src/observability/integrations/utils.ts
async function discoverIntegrations() {
  const integrations = {};
  try {
    await import("langchain");
    const { LangChainIntegration: LangChainIntegration2 } = await Promise.resolve().then(() => (init_langchain(), langchain_exports));
    integrations.langchain = LangChainIntegration2;
  } catch (_) {
  }
  try {
    await import("langgraph");
    const { LangGraphIntegration: LangGraphIntegration2 } = await Promise.resolve().then(() => (init_langgraph(), langgraph_exports));
    integrations.langgraph = LangGraphIntegration2;
  } catch (_) {
  }
  return integrations;
}
var init_utils = __esm({
  "src/observability/integrations/utils.ts"() {
    "use strict";
  }
});

// src/observability/Tracer.ts
var import_async_hooks, import_crypto2, import_timers, logger3, als, Tracer, tracer;
var init_Tracer = __esm({
  "src/observability/Tracer.ts"() {
    "use strict";
    import_async_hooks = require("async_hooks");
    import_crypto2 = require("crypto");
    init_Span();
    init_writer();
    import_timers = require("timers");
    init_utils();
    init_logger();
    if (process.env.ZEROEVAL_DEBUG?.toLowerCase() === "true") {
      Logger.setDebugMode(true);
    }
    logger3 = getLogger("zeroeval.tracer");
    als = new import_async_hooks.AsyncLocalStorage();
    Tracer = class {
      constructor() {
        this._writer = new BackendSpanWriter();
        this._buffer = [];
        this._flushIntervalMs = 1e4;
        // default 10 s
        this._maxSpans = 100;
        this._lastFlush = Date.now();
        this._activeTraceCounts = {};
        this._traceBuckets = {};
        this._integrations = {};
        this._shuttingDown = false;
        logger3.debug("Initializing tracer...");
        logger3.debug(
          `Tracer config: flush_interval=${this._flushIntervalMs}ms, max_spans=${this._maxSpans}`
        );
        (0, import_timers.setInterval)(() => {
          if (Date.now() - this._lastFlush >= this._flushIntervalMs) {
            void this.flush().catch((error) => {
              logger3.error("[ZeroEval] Periodic flush failed:", error);
            });
          }
        }, 1e3).unref();
        void this._setupAvailableIntegrations();
        process.on("beforeExit", () => this.shutdown());
        process.on("SIGINT", () => {
          this.shutdown();
          process.exit();
        });
        process.on("SIGTERM", () => {
          this.shutdown();
          process.exit();
        });
      }
      /* CONFIG ----------------------------------------------------------------*/
      configure(opts = {}) {
        if (opts.flushInterval !== void 0) {
          this._flushIntervalMs = opts.flushInterval * 1e3;
          logger3.info(
            `Tracer flush_interval configured to ${opts.flushInterval}s.`
          );
        }
        if (opts.maxSpans !== void 0) {
          this._maxSpans = opts.maxSpans;
          logger3.info(`Tracer max_spans configured to ${opts.maxSpans}.`);
        }
        logger3.debug(`Tracer configuration updated:`, opts);
      }
      /* ACTIVE SPAN -----------------------------------------------------------*/
      currentSpan() {
        const stack = als.getStore();
        return stack && stack[stack.length - 1];
      }
      /* TRACING ---------------------------------------------------------------*/
      startSpan(name, opts = {}) {
        logger3.debug(`Starting span: ${name}`);
        const parent = this.currentSpan();
        const span2 = new Span(name, parent?.traceId);
        if (parent) {
          span2.parentId = parent.spanId;
          span2.sessionId = parent.sessionId;
          span2.sessionName = parent.sessionName;
          span2.tags = { ...parent.tags, ...opts.tags };
          logger3.debug(`Span ${name} inherits from parent ${parent.name}`);
        } else {
          span2.sessionId = opts.sessionId ?? (0, import_crypto2.randomUUID)();
          span2.sessionName = opts.sessionName;
          span2.tags = { ...opts.tags };
          logger3.debug(
            `Span ${name} is a root span with session ${span2.sessionId}`
          );
        }
        Object.assign(span2.attributes, opts.attributes);
        const parentStack = als.getStore() ?? [];
        als.enterWith([...parentStack, span2]);
        this._activeTraceCounts[span2.traceId] = (this._activeTraceCounts[span2.traceId] || 0) + 1;
        return span2;
      }
      endSpan(span2) {
        var _a, _b;
        if (!span2.endTime)
          span2.end();
        logger3.debug(`Ending span: ${span2.name} (duration: ${span2.durationMs}ms)`);
        const stack = als.getStore();
        if (stack && stack[stack.length - 1] === span2) {
          stack.pop();
        }
        const traceBucket = (_a = this._traceBuckets)[_b = span2.traceId] || (_a[_b] = []);
        traceBucket.push(span2);
        this._activeTraceCounts[span2.traceId] -= 1;
        if (this._activeTraceCounts[span2.traceId] === 0) {
          delete this._activeTraceCounts[span2.traceId];
          const ordered = traceBucket.sort((a) => a.parentId ? 1 : -1);
          delete this._traceBuckets[span2.traceId];
          this._buffer.push(...ordered);
          logger3.debug(
            `Trace ${span2.traceId} complete with ${ordered.length} spans`
          );
        }
        if (this._buffer.length >= this._maxSpans) {
          logger3.debug(
            `Buffer full (${this._buffer.length} spans), triggering flush`
          );
          void this.flush().catch((error) => {
            logger3.error("[ZeroEval] Buffer full flush failed:", error);
          });
        }
      }
      /* TAG HELPERS -----------------------------------------------------------*/
      addTraceTags(traceId, tags) {
        logger3.debug(`Adding trace tags to ${traceId}:`, tags);
        for (const span2 of this._traceBuckets[traceId] ?? [])
          Object.assign(span2.tags, tags);
        this._buffer.filter((s) => s.traceId === traceId).forEach((s) => Object.assign(s.tags, tags));
      }
      addSessionTags(sessionId, tags) {
        logger3.debug(`Adding session tags to ${sessionId}:`, tags);
        const all = [...Object.values(this._traceBuckets).flat(), ...this._buffer];
        all.filter((s) => s.sessionId === sessionId).forEach((s) => Object.assign(s.tags, tags));
      }
      isActiveTrace(traceId) {
        return traceId in this._activeTraceCounts || traceId in this._traceBuckets;
      }
      /* FLUSH -----------------------------------------------------------------*/
      async flush() {
        if (this._buffer.length === 0)
          return;
        const spanCount = this._buffer.length;
        logger3.info(`[ZeroEval] Flushing ${spanCount} spans to backend...`);
        this._lastFlush = Date.now();
        const spansToFlush = this._buffer.splice(0);
        try {
          const startTime = Date.now();
          await this._writer.write(spansToFlush);
          const duration = Date.now() - startTime;
          logger3.info(
            `[ZeroEval] Successfully flushed ${spanCount} spans in ${duration}ms`
          );
        } catch (error) {
          logger3.error(
            `[ZeroEval] Failed to flush ${spanCount} spans:`,
            error instanceof Error ? error.message : error
          );
          this._buffer.unshift(...spansToFlush);
          throw error;
        }
      }
      async _setupAvailableIntegrations() {
        logger3.info("Checking for available integrations...");
        const available = await discoverIntegrations();
        for (const [key, Ctor] of Object.entries(available)) {
          try {
            const inst = new Ctor();
            if (Ctor.isAvailable?.() !== false) {
              logger3.info(`Setting up integration: ${key}`);
              inst.setup();
              this._integrations[key] = inst;
              logger3.info(`\u2705 Successfully set up integration: ${key}`);
            }
          } catch (err) {
            logger3.error(`\u274C Failed to setup integration ${key}:`, err);
          }
        }
        if (Object.keys(this._integrations).length > 0) {
          logger3.info(
            `Active integrations: ${Object.keys(this._integrations).join(", ")}`
          );
        } else {
          logger3.info("No active integrations found.");
        }
      }
      /** Flush remaining spans and teardown integrations */
      shutdown() {
        if (this._shuttingDown)
          return;
        this._shuttingDown = true;
        logger3.info("Shutting down tracer...");
        void this.flush().catch((error) => {
          logger3.error("[ZeroEval] Shutdown flush failed:", error);
        });
        for (const inst of Object.values(this._integrations)) {
          try {
            inst.teardown();
          } catch (error) {
            logger3.error("[ZeroEval] Integration teardown failed:", error);
          }
        }
      }
    };
    tracer = new Tracer();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  LangChainIntegration: () => LangChainIntegration,
  Span: () => Span,
  getCurrentSession: () => getCurrentSession,
  getCurrentSpan: () => getCurrentSpan,
  getCurrentTrace: () => getCurrentTrace,
  getEntitySignals: () => getEntitySignals,
  init: () => init,
  isInitialized: () => isInitialized,
  sendBulkSignals: () => sendBulkSignals,
  sendSessionSignal: () => sendSessionSignal,
  sendSignal: () => sendSignal,
  sendSpanSignal: () => sendSpanSignal,
  sendTraceSignal: () => sendTraceSignal,
  setTag: () => setTag,
  span: () => span,
  tracer: () => tracer,
  validateInit: () => validateInit,
  withSpan: () => withSpan,
  wrap: () => wrap,
  wrapOpenAI: () => wrapOpenAI,
  wrapVercelAI: () => wrapVercelAI
});
module.exports = __toCommonJS(src_exports);

// src/init.ts
init_Tracer();
init_logger();
var logger4 = getLogger("zeroeval");
var initialized = false;
function isInitialized() {
  return initialized;
}
function validateInit() {
  const logger6 = getLogger("zeroeval");
  if (!process.env.ZEROEVAL_WORKSPACE_NAME || !process.env.ZEROEVAL_API_KEY) {
    logger6.error(
      "ZeroEval SDK not initialized. Please call ze.init(apiKey='YOUR_API_KEY') first."
    );
    return false;
  }
  return true;
}
function init(opts = {}) {
  const {
    apiKey,
    apiUrl,
    workspaceName = "Personal Workspace",
    flushInterval,
    maxSpans,
    collectCodeDetails,
    integrations,
    debug
  } = opts;
  const isDebugMode = debug || process.env.ZEROEVAL_DEBUG?.toLowerCase() === "true";
  if (isDebugMode) {
    process.env.ZEROEVAL_DEBUG = "true";
    Logger.setDebugMode(true);
    const maskedApiKey = Logger.maskApiKey(
      apiKey || process.env.ZEROEVAL_API_KEY
    );
    const finalApiUrl = apiUrl || process.env.ZEROEVAL_API_URL || "https://api.zeroeval.com";
    logger4.debug("ZeroEval SDK Configuration:");
    logger4.debug(`  Workspace: ${workspaceName}`);
    logger4.debug(`  API Key: ${maskedApiKey}`);
    logger4.debug(`  API URL: ${finalApiUrl}`);
    logger4.debug(`  Debug Mode: ${isDebugMode}`);
    logger4.debug(`  Flush Interval: ${flushInterval ?? "10s (default)"}`);
    logger4.debug(`  Max Spans: ${maxSpans ?? "100 (default)"}`);
    logger4.debug(
      `  Collect Code Details: ${collectCodeDetails ?? "true (default)"}`
    );
    logger4.info("SDK initialized in debug mode.");
  } else {
    Logger.setDebugMode(false);
  }
  process.env.ZEROEVAL_WORKSPACE_NAME = workspaceName;
  if (apiKey)
    process.env.ZEROEVAL_API_KEY = apiKey;
  if (apiUrl)
    process.env.ZEROEVAL_API_URL = apiUrl;
  tracer.configure({
    flushInterval,
    maxSpans,
    collectCodeDetails,
    integrations
  });
  initialized = true;
}

// src/observability/spanDecorator.ts
init_Tracer();
function span(opts) {
  return function(_target, _propertyKey, descriptor) {
    if (descriptor && typeof descriptor.value === "function") {
      const original = descriptor.value;
      const isAsync = original.constructor.name === "AsyncFunction";
      const wrapper = function(...args) {
        const spanInst = tracer.startSpan(opts.name, {
          attributes: opts.attributes,
          sessionId: opts.sessionId,
          sessionName: opts.sessionName,
          tags: opts.tags
        });
        try {
          const result = original.apply(this, args);
          if (isAsync && result && typeof result.then === "function") {
            return result.then((r) => {
              if (opts.inputData === void 0) {
                const output = opts.outputData !== void 0 ? typeof opts.outputData === "string" ? opts.outputData : JSON.stringify(opts.outputData, replacer, 2) : typeof r === "string" ? r : JSON.stringify(r, replacer, 2);
                spanInst.setIO(JSON.stringify(args, replacer, 2), output);
              } else {
                const output = opts.outputData !== void 0 ? opts.outputData : r;
                spanInst.setIO(opts.inputData, output);
              }
              tracer.endSpan(spanInst);
              return r;
            }).catch((err) => {
              spanInst.setError({
                code: err?.name,
                message: err?.message,
                stack: err?.stack
              });
              tracer.endSpan(spanInst);
              throw err;
            });
          }
          if (opts.inputData === void 0) {
            const output = opts.outputData !== void 0 ? typeof opts.outputData === "string" ? opts.outputData : JSON.stringify(opts.outputData, replacer, 2) : typeof result === "string" ? result : JSON.stringify(result, replacer, 2);
            spanInst.setIO(JSON.stringify(args, replacer, 2), output);
          } else {
            const output = opts.outputData !== void 0 ? opts.outputData : result;
            spanInst.setIO(opts.inputData, output);
          }
          tracer.endSpan(spanInst);
          return result;
        } catch (err) {
          spanInst.setError({
            code: err?.name,
            message: err?.message,
            stack: err?.stack
          });
          tracer.endSpan(spanInst);
          throw err;
        }
      };
      Object.defineProperty(wrapper, "name", { value: original.name });
      descriptor.value = wrapper;
      return descriptor;
    }
  };
}
function withSpan(opts, fn) {
  const spanInst = tracer.startSpan(opts.name, {
    attributes: opts.attributes,
    sessionId: opts.sessionId,
    sessionName: opts.sessionName,
    tags: opts.tags
  });
  try {
    const result = fn();
    if (result && typeof result.then === "function") {
      return result.then((res) => {
        if (opts.inputData !== void 0 || opts.outputData !== void 0) {
          const output = opts.outputData !== void 0 ? opts.outputData : res;
          spanInst.setIO(opts.inputData, output);
        }
        tracer.endSpan(spanInst);
        return res;
      }).catch((err) => {
        spanInst.setError({
          code: err?.name,
          message: err?.message,
          stack: err?.stack
        });
        tracer.endSpan(spanInst);
        throw err;
      });
    }
    if (opts.inputData !== void 0 || opts.outputData !== void 0) {
      const output = opts.outputData !== void 0 ? opts.outputData : result;
      spanInst.setIO(opts.inputData, output);
    }
    tracer.endSpan(spanInst);
    return result;
  } catch (err) {
    spanInst.setError({
      code: err?.name,
      message: err?.message,
      stack: err?.stack
    });
    tracer.endSpan(spanInst);
    throw err;
  }
}
function replacer(_key, value) {
  if (typeof value === "bigint")
    return value.toString();
  if (typeof value === "function")
    return `[Function ${value.name || "anonymous"}]`;
  return value;
}

// src/index.ts
init_Tracer();

// src/helpers.ts
init_Tracer();
function getCurrentSpan() {
  return tracer.currentSpan();
}
function getCurrentTrace() {
  return tracer.currentSpan()?.traceId;
}
function getCurrentSession() {
  return tracer.currentSpan()?.sessionId;
}
function setTag(target, tags) {
  if (!target || !tags || typeof tags !== "object")
    return;
  if (typeof target !== "string") {
    Object.assign(target.tags, tags);
  } else {
    if (tracer.isActiveTrace(target)) {
      tracer.addTraceTags(target, tags);
    } else {
      tracer.addSessionTags(target, tags);
    }
  }
}

// src/observability/integrations/openaiWrapper.ts
init_Tracer();
function wrapOpenAI(client) {
  if (client.__zeroeval_wrapped) {
    return client;
  }
  const wrappedClient = new Proxy(client, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "__zeroeval_wrapped") {
        return true;
      }
      if (prop === "chat") {
        return new Proxy(value, {
          get(chatTarget, chatProp) {
            const chatValue = Reflect.get(chatTarget, chatProp);
            if (chatProp === "completions") {
              return new Proxy(chatValue, {
                get(completionsTarget, completionsProp) {
                  const completionsValue = Reflect.get(
                    completionsTarget,
                    completionsProp
                  );
                  if (completionsProp === "create") {
                    return wrapCompletionsCreate(
                      completionsValue.bind(completionsTarget)
                    );
                  }
                  if (completionsProp === "retrieve" || completionsProp === "update" || completionsProp === "list" || completionsProp === "delete") {
                    return wrapGenericMethod(
                      completionsValue.bind(completionsTarget),
                      `openai.chat.completions.${String(completionsProp)}`
                    );
                  }
                  return completionsValue;
                }
              });
            }
            return chatValue;
          }
        });
      }
      if (prop === "embeddings" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(embeddingsTarget, embeddingsProp) {
            const embeddingsValue = Reflect.get(
              embeddingsTarget,
              embeddingsProp
            );
            if (embeddingsProp === "create" && typeof embeddingsValue === "function") {
              return wrapGenericMethod(
                embeddingsValue.bind(embeddingsTarget),
                "openai.embeddings.create"
              );
            }
            return embeddingsValue;
          }
        });
      }
      if (prop === "images" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(imagesTarget, imagesProp) {
            const imagesValue = Reflect.get(imagesTarget, imagesProp);
            if ((imagesProp === "generate" || imagesProp === "edit" || imagesProp === "createVariation") && typeof imagesValue === "function") {
              return wrapGenericMethod(
                imagesValue.bind(imagesTarget),
                `openai.images.${String(imagesProp)}`
              );
            }
            return imagesValue;
          }
        });
      }
      if (prop === "audio" && typeof value === "object" && value !== null) {
        return new Proxy(value, {
          get(audioTarget, audioProp) {
            const audioValue = Reflect.get(audioTarget, audioProp);
            if ((audioProp === "transcriptions" || audioProp === "translations") && typeof audioValue === "object" && audioValue !== null) {
              return new Proxy(audioValue, {
                get(subTarget, subProp) {
                  const subValue = Reflect.get(subTarget, subProp);
                  if (subProp === "create" && typeof subValue === "function") {
                    return wrapGenericMethod(
                      subValue.bind(subTarget),
                      `openai.audio.${String(audioProp)}.create`
                    );
                  }
                  return subValue;
                }
              });
            }
            return audioValue;
          }
        });
      }
      return value;
    }
  });
  return wrappedClient;
}
function wrapCompletionsCreate(originalMethod) {
  return async function wrappedCreate(...args) {
    const [params] = args;
    const isStreaming = !!params?.stream;
    const startTime = Date.now() / 1e3;
    if (isStreaming && params?.model && typeof params.model === "string" && !params.model.includes("/")) {
      params.stream_options = { include_usage: true };
    }
    const serializedMessages = params?.messages ? params.messages.map((msg) => ({
      role: msg.role,
      content: msg.content
    })) : [];
    const span2 = tracer.startSpan("openai.chat.completions.create", {
      attributes: {
        "service.name": "openai",
        kind: "llm",
        provider: "openai",
        model: params?.model,
        messages: serializedMessages,
        streaming: isStreaming
      },
      tags: { integration: "openai" }
    });
    try {
      const result = await originalMethod(...args);
      if (isStreaming && result && typeof result[Symbol.asyncIterator] === "function") {
        return wrapStream(result, span2, serializedMessages, startTime);
      }
      if (!isStreaming && result) {
        const elapsed = Date.now() / 1e3 - startTime;
        const output = result.choices?.[0]?.message?.content || "";
        if (result.usage) {
          span2.attributes.inputTokens = result.usage.prompt_tokens;
          span2.attributes.outputTokens = result.usage.completion_tokens;
        }
        const throughput = output.length > 0 && elapsed > 0 ? Math.round(output.length / elapsed * 100) / 100 : 0;
        span2.attributes.throughput = throughput;
        span2.setIO(JSON.stringify(serializedMessages), output);
      }
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
}
function wrapGenericMethod(originalMethod, spanName) {
  return async function wrappedMethod(...args) {
    const [params] = args;
    let kind = "operation";
    if (spanName.includes("embeddings")) {
      kind = "embedding";
    }
    const span2 = tracer.startSpan(spanName, {
      attributes: {
        "service.name": "openai",
        kind,
        provider: "openai",
        ...params?.model && { model: params.model }
      },
      tags: { integration: "openai" }
    });
    try {
      const result = await originalMethod(...args);
      let output;
      if (result?.data && Array.isArray(result.data)) {
        output = `${result.data.length} items`;
      } else if (result?.text) {
        output = result.text;
      } else if (result?.embedding) {
        output = `embedding[${result.embedding.length}]`;
      } else {
        output = JSON.stringify(result);
      }
      span2.setIO(JSON.stringify(params), output);
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
}
async function* wrapStream(stream, span2, serializedMessages, startTime) {
  const chunks = [];
  let errorOccurred = false;
  let firstTokenTime = null;
  let fullResponse = "";
  try {
    for await (const chunk of stream) {
      if (!chunk.choices && chunk.usage) {
        span2.attributes.inputTokens = chunk.usage.prompt_tokens;
        span2.attributes.outputTokens = chunk.usage.completion_tokens;
        chunks.push(chunk);
        yield chunk;
        continue;
      }
      if (chunk.choices?.[0]?.delta?.content) {
        const content = chunk.choices[0].delta.content;
        if (firstTokenTime === null) {
          firstTokenTime = Date.now() / 1e3;
          span2.attributes.latency = Math.round((firstTokenTime - startTime) * 1e4) / 1e4;
        }
        fullResponse += content;
      }
      chunks.push(chunk);
      yield chunk;
    }
    const elapsed = Date.now() / 1e3 - startTime;
    const throughput = fullResponse.length > 0 && elapsed > 0 ? Math.round(fullResponse.length / elapsed * 100) / 100 : 0;
    span2.attributes.throughput = throughput;
    span2.setIO(JSON.stringify(serializedMessages), fullResponse);
  } catch (error) {
    errorOccurred = true;
    span2.setError({
      code: error?.name || "StreamError",
      message: error?.message || "Stream error occurred",
      stack: error?.stack
    });
    throw error;
  } finally {
    if (!errorOccurred) {
      tracer.endSpan(span2);
    }
  }
}

// src/observability/integrations/vercelAIWrapper.ts
init_Tracer();
function wrapVercelAIFunction(fn, functionName) {
  if (fn.__zeroeval_wrapped) {
    return fn;
  }
  if (!isInitialized()) {
    const envApiKey = process.env.ZEROEVAL_API_KEY;
    if (envApiKey) {
      init({ apiKey: envApiKey });
    }
  }
  const wrappedFn = async function wrappedVercelAIFunction(...args) {
    const [options] = args;
    const model = options?.model?.modelId || options?.model || "unknown";
    const messages = options?.messages;
    const prompt = options?.prompt;
    const tools = options?.tools;
    const maxSteps = options?.maxSteps;
    const maxRetries = options?.maxRetries;
    const temperature = options?.temperature;
    const maxTokens = options?.maxTokens;
    let kind = "operation";
    if (functionName === "generateText" || functionName === "streamText") {
      kind = "llm";
    } else if (functionName === "generateObject" || functionName === "streamObject") {
      kind = "llm";
    } else if (functionName === "embed" || functionName === "embedMany") {
      kind = "embedding";
    } else if (functionName === "generateImage") {
      kind = "image";
    } else if (functionName === "generateSpeech") {
      kind = "speech";
    } else if (functionName === "transcribe") {
      kind = "transcription";
    }
    const span2 = tracer.startSpan(`vercelai.${functionName}`, {
      attributes: {
        "service.name": "vercel-ai-sdk",
        kind,
        provider: "vercel-ai-sdk",
        model,
        ...messages && { messages },
        ...temperature !== void 0 && { temperature },
        ...maxTokens !== void 0 && { maxTokens },
        ...maxSteps !== void 0 && { maxSteps },
        ...maxRetries !== void 0 && { maxRetries },
        ...tools && { toolCount: Object.keys(tools).length },
        ...functionName.includes("stream") && { streaming: true }
      },
      tags: { integration: "vercel-ai-sdk" }
    });
    const startTime = Date.now() / 1e3;
    try {
      let input;
      if (messages) {
        input = JSON.stringify(messages);
      } else if (prompt) {
        input = typeof prompt === "string" ? prompt : JSON.stringify(prompt);
      } else {
        input = JSON.stringify(options);
      }
      const result = await fn(...args);
      if (result && typeof result === "object") {
        const elapsed = Date.now() / 1e3 - startTime;
        if ("text" in result) {
          const output = result.text || "";
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
            span2.attributes.outputTokens = result.usage.completionTokens;
          }
          const throughput = output.length > 0 && elapsed > 0 ? Math.round(output.length / elapsed * 100) / 100 : 0;
          span2.attributes.throughput = throughput;
          span2.setIO(input, String(output));
        } else if ("textStream" in result || "fullStream" in result) {
          return wrapStreamingResult(result, span2, input, startTime);
        } else if ("object" in result) {
          const output = result.object ? JSON.stringify(result.object) : "{}";
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
            span2.attributes.outputTokens = result.usage.completionTokens;
          }
          span2.setIO(input, output);
        } else if ("embedding" in result || "embeddings" in result) {
          const embeddingCount = result.embeddings?.length || 1;
          const output = `${embeddingCount} embedding(s) generated`;
          if (result.usage) {
            span2.attributes.inputTokens = result.usage.promptTokens;
          }
          span2.setIO(input, output);
        } else {
          span2.setIO(input, JSON.stringify(result));
        }
      } else {
        span2.setIO(input, String(result || ""));
      }
      tracer.endSpan(span2);
      return result;
    } catch (error) {
      span2.setError({
        code: error?.name || "UnknownError",
        message: error?.message || "An unknown error occurred",
        stack: error?.stack
      });
      tracer.endSpan(span2);
      throw error;
    }
  };
  wrappedFn.__zeroeval_wrapped = true;
  Object.defineProperty(wrappedFn, "name", { value: fn.name });
  Object.setPrototypeOf(wrappedFn, Object.getPrototypeOf(fn));
  return wrappedFn;
}
function wrapStreamingResult(result, span2, input, startTime) {
  return new Proxy(result, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "textStream" && value && typeof value[Symbol.asyncIterator] === "function") {
        return wrapAsyncIterator(value, span2, input, startTime, "text");
      }
      if (prop === "fullStream" && value && typeof value[Symbol.asyncIterator] === "function") {
        return wrapAsyncIterator(value, span2, input, startTime, "full");
      }
      if (prop === "consumeStream") {
        return async function() {
          try {
            const full = receiver.fullStream;
            const text = receiver.textStream;
            if (full && typeof full[Symbol.asyncIterator] === "function") {
              for await (const _ of full) {
              }
            } else if (text && typeof text[Symbol.asyncIterator] === "function") {
              for await (const _ of text) {
              }
            }
            try {
              tracer.endSpan(span2);
            } catch {
            }
          } catch (error) {
            span2.setError({
              code: error?.name || "StreamError",
              message: error?.message || "Stream error occurred",
              stack: error?.stack
            });
            try {
              tracer.endSpan(span2);
            } catch {
            }
            throw error;
          }
        };
      }
      if (prop === "toDataStreamResponse" && typeof value === "function") {
        return async function(...args) {
          const response = await value.apply(target, args);
          tracer.endSpan(span2);
          return response;
        };
      }
      if (prop === "toAIStreamResponse" && typeof value === "function") {
        return async function(...args) {
          const response = await value.apply(target, args);
          tracer.endSpan(span2);
          return response;
        };
      }
      if (prop === "toDataStream" && typeof value === "function") {
        return async function(...args) {
          const stream = await value.apply(target, args);
          tracer.endSpan(span2);
          return stream;
        };
      }
      return value;
    }
  });
}
async function* wrapAsyncIterator(iterator, span2, input, startTime, streamType) {
  let fullText = "";
  let chunkCount = 0;
  let tokenCount = 0;
  let firstTokenTime = null;
  try {
    for await (const chunk of iterator) {
      chunkCount++;
      if (firstTokenTime === null && (streamType === "text" && chunk || streamType === "full" && (chunk.type === "text-delta" || chunk.type === "text"))) {
        firstTokenTime = Date.now() / 1e3;
        span2.attributes.latency = Math.round((firstTokenTime - startTime) * 1e4) / 1e4;
      }
      if (streamType === "text" && typeof chunk === "string") {
        fullText += chunk;
      } else if (streamType === "full" && chunk) {
        if (chunk.type === "text-delta" && chunk.textDelta) {
          fullText += chunk.textDelta;
        } else if (chunk.type === "text" && chunk.text) {
          fullText += chunk.text;
        }
        if (chunk.usage) {
          tokenCount = chunk.usage.completionTokens || tokenCount;
          if (chunk.usage.promptTokens) {
            span2.attributes.inputTokens = chunk.usage.promptTokens;
          }
        }
      }
      yield chunk;
    }
    const elapsed = Date.now() / 1e3 - startTime;
    const throughput = fullText.length > 0 && elapsed > 0 ? Math.round(fullText.length / elapsed * 100) / 100 : 0;
    span2.attributes.throughput = throughput;
    span2.attributes.chunkCount = chunkCount;
    if (tokenCount > 0) {
      span2.attributes.outputTokens = tokenCount;
    }
    span2.setIO(input, fullText || "");
    tracer.endSpan(span2);
  } catch (error) {
    span2.setError({
      code: error?.name || "StreamError",
      message: error?.message || "An error occurred during streaming",
      stack: error?.stack
    });
    tracer.endSpan(span2);
    throw error;
  }
}
function wrapVercelAI(aiModule) {
  if (aiModule.__zeroeval_wrapped) {
    return aiModule;
  }
  const functionsToWrap = [
    "generateText",
    "streamText",
    "generateObject",
    "streamObject",
    "embed",
    "embedMany",
    "generateImage",
    "transcribe",
    "generateSpeech"
  ];
  const wrappedModule = {};
  for (const key in aiModule) {
    const value = aiModule[key];
    if (functionsToWrap.includes(key) && typeof value === "function") {
      wrappedModule[key] = wrapVercelAIFunction(value, key);
    } else {
      wrappedModule[key] = value;
    }
  }
  wrappedModule.__zeroeval_wrapped = true;
  Object.setPrototypeOf(wrappedModule, Object.getPrototypeOf(aiModule));
  return wrappedModule;
}

// src/observability/integrations/wrapper.ts
function isOpenAIClient(client) {
  if (typeof client !== "object" || client === null) {
    return false;
  }
  const obj = client;
  return obj.chat !== void 0 && typeof obj.chat === "object" && obj.chat !== null && "completions" in obj.chat && obj.embeddings !== void 0 && typeof obj.embeddings === "object" && obj.embeddings !== null && "create" in obj.embeddings && obj.constructor !== void 0 && typeof obj.constructor === "function" && obj.constructor.name === "OpenAI";
}
function isVercelAIModule(client) {
  if (typeof client !== "object" || client === null) {
    return false;
  }
  const obj = client;
  return typeof obj.generateText === "function" || typeof obj.streamText === "function" || typeof obj.generateObject === "function" || typeof obj.embed === "function";
}
function wrap(client) {
  if (client.__zeroeval_wrapped) {
    return client;
  }
  if (!isInitialized()) {
    const envApiKey = process.env.ZEROEVAL_API_KEY;
    if (envApiKey) {
      init({ apiKey: envApiKey });
    }
  }
  if (isOpenAIClient(client)) {
    return wrapOpenAI(client);
  }
  if (isVercelAIModule(client)) {
    return wrapVercelAI(client);
  }
  let clientType = "unknown";
  if (typeof client === "object" && client !== null) {
    const obj = client;
    if (obj.constructor && typeof obj.constructor === "function") {
      const ctor = obj.constructor;
      clientType = ctor.name || "unknown";
    }
  } else {
    clientType = typeof client;
  }
  throw new Error(
    `Unsupported client type. ze.wrap() currently supports:
- OpenAI clients (from 'openai' package)
- Vercel AI SDK (from 'ai' package)

Received: ${clientType}

Make sure you're passing a valid client instance, e.g.:
  const openai = ze.wrap(new OpenAI());
  const ai = ze.wrap(await import('ai'));`
  );
}

// src/index.ts
init_Span();
init_langchain();

// src/signals.ts
init_signalWriter();

// src/observability/signals.ts
function detectSignalType(value) {
  if (typeof value === "boolean") {
    return "boolean";
  }
  if (typeof value === "number") {
    return "numerical";
  }
  const strVal = String(value).toLowerCase();
  if (strVal === "true" || strVal === "false") {
    return "boolean";
  }
  const num = Number(value);
  if (!isNaN(num)) {
    return "numerical";
  }
  return "boolean";
}

// src/signals.ts
init_Tracer();
init_pendingSignals();
init_logger();
var logger5 = getLogger("zeroeval.signals");
async function sendSignal(entityType, entityId, name, value, signalType) {
  const signal = {
    entity_type: entityType,
    entity_id: entityId,
    name,
    value,
    signal_type: signalType || detectSignalType(value)
  };
  await signalWriter.createSignal(signal);
}
async function sendBulkSignals(signals) {
  await signalWriter.createBulkSignals(signals);
}
function sendTraceSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan) {
    logger5.warn(
      "[ZeroEval] No active span/trace found for sending trace signal"
    );
    return;
  }
  const sig = {
    value,
    type: signalType || detectSignalType(value)
  };
  addPendingTraceSignal(currentSpan.traceId, name, sig);
}
function sendSessionSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan || !currentSpan.sessionId) {
    logger5.warn(
      "[ZeroEval] No active session found for sending session signal"
    );
    return;
  }
  const sig = {
    value,
    type: signalType || detectSignalType(value)
  };
  addPendingSessionSignal(currentSpan.sessionId, name, sig);
}
function sendSpanSignal(name, value, signalType) {
  const currentSpan = tracer.currentSpan();
  if (!currentSpan) {
    logger5.warn("[ZeroEval] No active span found for sending span signal");
    return;
  }
  currentSpan.addSignal(name, value, signalType);
}
async function getEntitySignals(entityType, entityId) {
  const result = await signalWriter.getEntitySignals(
    entityType,
    entityId
  );
  if (!result || !Array.isArray(result)) {
    return [];
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LangChainIntegration,
  Span,
  getCurrentSession,
  getCurrentSpan,
  getCurrentTrace,
  getEntitySignals,
  init,
  isInitialized,
  sendBulkSignals,
  sendSessionSignal,
  sendSignal,
  sendSpanSignal,
  sendTraceSignal,
  setTag,
  span,
  tracer,
  validateInit,
  withSpan,
  wrap,
  wrapOpenAI,
  wrapVercelAI
});
